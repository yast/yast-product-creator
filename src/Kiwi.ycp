/**
 * File:	modules/Kiwi.ycp
 * Package:	Configuration of product-creator
 * Summary:	Data for kiwi configuration, input and output functions.
 * Authors:	Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 */
{
  module "Kiwi";

  textdomain "product-creator";

  import "Arch";
  import "Directory";
  import "FileUtils";
  import "Label";
  import "Message";
  import "Package";
  import "Popup";
  import "ProductCreator";
  import "Progress";
  import "Report";
  import "Security";
  import "String";
  import "URL";

  // path to file with global repo aliases (fate#312133)
  string aliases_path           = "/etc/kiwi/repoalias";

  // mapping of repository aliases to real URLs
  // nil means not activated
  map<string,string> alias2url  = nil;

  // mapping of repo URLs to alias - only those used in last read
  // (so not the reverse of alias2url map)
  map<string,string> url2alias  = $[];

  /**
   * argument for any_xml agent: key indicating content of element without
   * attributes
   */
  global string content_key	= "__yast_content__";

  // default image size, if none was given (in MB)
  global string default_size    = "10";

  include "product-creator/routines.ycp";

  string encryption_method	= nil;

  // temporary directory, where kiwi is working
  global string tmp_dir	= "";

  // directory for saving image configurations
  global string images_dir	= Directory::vardir + "/product-creator/images";

  // bug 331733
  global string supported_boot_images	= "";

  // target architecture of image (can be only i386 if different from current one)
  global string image_architecture	= "";

  // if target architecture should be i586 instead of i686
  global boolean target_i586		= false;

  // directories with user-made templated
  global list<string> templates_dirs	= [];

  global string default_packagemanager	= "zypper";

  list<map> all_sources		= [];

  // repositories used for current configuration
  global map <string,map> current_repositories	= $[];

  // initial system repositories
  global map <string,map> initial_repositories	= $[];

  // where the kiwi configuration files are stored
  string config_dir	= "";

  // chroot directory for creating the physical extend
  string chroot_dir	= "";

  // What we want to create with kiwi
  global string kiwi_task	= "iso";

  // map with image templates (to base new projects on)
  global map<string,map> Templates		= $[];

  string stdout_file   = "image_creator.stdout";
  string stderr_file   = "image_creator.stderr";
  string logs_directory	= "/tmp";

  // all available locales
  global map<string,integer> all_locales        = $[];

  // all available time zones
  global list<string> all_timezones	= [];

  /**
   * crypt given user password with current encryption algorithm
   */
  string crypt_password	(string pw)
  {
    if (pw == "") return pw;
    if (encryption_method == nil)
    {
	boolean progress = Progress::set (false);
	Security::Read ();
	Progress::set (progress);
	map security	= Security::Export ();
	encryption_method  = tolower (security["PASSWD_ENCRYPTION"]:"des");
    }
    if (encryption_method == "md5")
	return cryptmd5 (pw);
    if (encryption_method == "blowfish")
	return cryptblowfish (pw);
    return crypt (pw);
  }

  /**
   * change the yast source path format to kiwi (smart?) one
   */
  string adapt_source_path (string source) {

    if (substring (source, 0, 6) == "dir://")
	return substring (source, 6);
    return source;
  }

  /**
   * generate the 'repository' tag
   */
  map get_source_value (string source, map config) {

    map ret	= $[];
    // first check if we weren't importing this source:
    foreach (string url, map repo, current_repositories, {
	if (url == source && repo["org"]:$[] != $[])
	{
	    ret	= repo["org"]:$[];
	}
    });
    string adapted      = adapt_source_path (source);
    if (haskey (url2alias, source) || haskey (url2alias, adapted))
    {
        ret["source",0,"path"]  = url2alias[source]:url2alias[adapted]:"";
        y2milestone ("alias for %1 is %2", source, ret["source",0,"path"]:"");
        return ret;
    }

    if (ret != $[])
    {
	y2milestone ("imported source: %1", source);
	return ret;
    }

    // ... otherwise, we must ask zypp:
    string type		= "yast2";

    foreach (map sourcemap, all_sources, {
	integer srcid	= sourcemap["SrcId"]:-1;
        map data	= Pkg::SourceGeneralData (srcid);
	string url	= data["url"]:"";
	if (adapt_source_path (url) == adapted)
	{
	    if (data["type"]:"" == "NONE")
		data["type"]	= Pkg::RepositoryProbe (url, "");
	    if (data["type"]:"" == "Plaindir")
		type	= "rpm-dir";
	    if (data["type"]:"" == "YUM")
		type	= "rpm-md";
	    map parsed = URL::Parse(url);
	    if (parsed["scheme"]:"" == "https")
	    {
		// change source url to contain password
		source      = Pkg::SourceURL (srcid);
	    }
	}
    });
    return $[
        "source": [
	    $[
		"path"	: adapt_source_path (source),
	    ]
	],
	"type"	: type
    ];
  }

  /**
   * generate the name of directory with kiwi configuration
   */
  string get_config_dir (string name, string task) {
    return deletechars (name, " \t");
  }



  /**
   * convert YCP map (of type read from any_xml agent) to XML
   */
  string MapAny2XML (string item_key, map item_descr, integer level) {

    string tab		= "";
    integer i		= 0;
    while (i < level) {
	i = i + 1;
	tab	= tab + "  ";
    }
    string ret		= tab + "<" + item_key;
    string attr		= "";
    string subret	= "";
    string content	= "";
    foreach (string key, any value, (map<string,any>) item_descr, {

	if (is (value, list))
	{
	    foreach (map it_map, (list<map>) value, {
		subret	= subret + "\n" + MapAny2XML (key, it_map, level + 1);
	    });
	}
	else if (is (value,string) || is (value,integer) || is (value,boolean))
	{
	    if (key == content_key)
		content	= String::EscapeTags (tostring (value));
	    else
		attr = attr + sformat (" %1=\"%2\"",
		    key, String::EscapeTags (tostring (value))
		);
	}
    });
    ret	= ret + attr;
    ret	= ret + ((subret == "" && content == "")? "/>" : ">");
    if (content != "")
	ret	= ret + content + sformat ("</%1>", item_key);
    else if (subret != "")
	ret	= ret + subret + "\n" + tab + sformat ("</%1>", item_key);
    return ret;
  }

  /**
   * Transform given XML file using given XSL transformation file
   * Return path to new file if transformation was done and was successful
   * @param config_path path to XML file
   * @param xsl_file path to XSL file
   */
  string XSLTTransform (string config_path, string xsl_file) {
    string ret_path	= config_path;
    if (Package::Installed ("libxslt") && FileUtils::Exists (xsl_file))
    {
	// new path identified by xsl file:
	// config-usr-share-kiwi-xsl-convertSleposSp1toSp2-xsl.xml
	ret_path	= sformat ("%1/config%2.xml",
	    Directory::tmpdir,
	    mergestring (splitstring (xsl_file, "/ ."), "-"));
	map out = (map) SCR::Execute (.target.bash_output, sformat (
	    "/usr/bin/xsltproc '%1' '%2' > %3",
	    String::Quote (xsl_file), String::Quote (config_path), ret_path));
	if (out["exit"]:0 != 0)
	{
	    y2error ("xslt transformation failed: %1", out);
	    ret_path	= config_path;
	}
    }
    return ret_path;
  }

  /**
   * Read global list of repository aliases
   */
  global map<string,string> ReadAliases (boolean force) {
    if (alias2url != nil && !force)
    {
      return alias2url;
    }
    alias2url = $[];
    if (FileUtils::Exists (aliases_path))
    {
      list<string> aliases      = (list<string>) SCR::Dir (.etc.kiwi.repoalias.v);
      if (aliases == nil)
      {
        y2warning ("aliases file broken, empty or not for reading...");
      }
      else
      {
        foreach (string alias, aliases, {
          string url    = (string) SCR::Read (add (.etc.kiwi.repoalias.v, alias));
          if (url == nil || url == "")
          {
            y2warning ("alias '%1' incorrectly defined: '%2'", alias, url);
          }
          else
          {
            alias2url[alias]    = url;
          }
        });
      }
    }
    return alias2url;
  }

  /**
   * import the data from given config.xml
   * @param directory where to look for config.xml
   * @ret map of imported data
   */
  global map<string,any> ReadConfigXML (string base_path) {

    map<string,any> ret	= $[];
    if (!FileUtils::Exists (base_path + "/config.xml"))
    {
	y2warning ("no such file %1/config.xml", base_path);
	return ret;
    }
    url2alias           = $[];
    string file_path	=  base_path + "/config.xml";

    // transformation to latest kiwi version
    file_path = XSLTTransform (file_path, "/usr/share/kiwi/xsl/master.xsl");
    // transformation to latest SLEPOs version (bnc#723031)
    string slepos_path = XSLTTransform (file_path, "/usr/share/kiwi/xsl/convertSleposSp1toSp2.xsl");
    // make a backup when SLEPOS transformation changed anything
    if (slepos_path != file_path)
    {
	map out = (map) SCR::Execute (.target.bash_output, sformat (
	    "diff -1 '%1' '%2'", file_path, slepos_path));
	if (out["exit"]:0 != 0)
	{
	    string backup	=  base_path + "/config.xml.POSsave";
	    y2milestone ("creating backup of config file: %1", backup);
	    SCR::Execute (.target.bash, sformat ("cp -- '%1/config.xml' '%2'",
	        String::Quote (base_path), String::Quote (backup)));
	}
	file_path	= slepos_path;
    }

    // read rest of config.xml using more generic agent
    map anyxml		= (map) SCR::Read (.anyxml, $[
	"file"	: file_path,
	"args"	: $[
	    "ForceArray"	: 1,
            "KeepRoot"		: 1,
	    "KeyAttr"		: [],
	    "ForceContent"	: 1,
	    "ContentKey"	: content_key,
	]
    ]);
    map image		= anyxml["image",0]:$[];

    // attributes of 'image' tag:
    ret["name"]		= image["name"]:"";
    ret["schemaversion"]= image["schemaversion"]:"5.2";
    if (haskey (image, "inherit"))
	ret["inherit"]	= image["inherit"]:"";

    ret["preferences"]	= image["preferences"]:[];
    ret["description"]	= image["description"]:[];
    ret["users"]	= maplist (map gmap, (list<map>)image["users"]:[], {
	// convert integer values to strings
	gmap["user"]	= maplist (map umap, (list<map>) gmap["user"]:[], {
	    if (umap["id"]:nil != nil)
		umap["id"]	= sformat ("%1", umap["id"]:nil);
	    // add internal info if password was already crypted
	    umap["encrypted"]	= (umap["pwd"]:nil != nil);
	    return umap;
	});
	if (gmap["id"]:nil != nil)
	    gmap["id"]	= sformat ("%1", gmap["id"]:nil);
	return gmap;
    });
    ret["packages"]	= image["packages"]:[];
    ret["profiles"]	= image["profiles"]:[];
    ret["split"]	= image["split"]:[];

    if (image["repository"]:nil != nil)
    {
        // check repo aliases and replace with real paths for YaST
        ReadAliases (false);
        list<map> image_repos   = image["repository"]:[];
        ret["repository"]	= maplist (map repo, image["repository"]:[], {
          string source	= repo["source",0,"path"]:"";
          string url    = alias2url[source]:"";
          if (url != "")
          {
              repo["source",0,"path"]   = url;
              // save alias for writing:
              url2alias[url]            = source;
              y2milestone ("alias %1 replaced with %2", source, url);
          }
          return repo;
        });
    }

    // FIXME iso-directory should be used only when converting PC->IC
    if (haskey (ret["preferences",0]:$[], "defaultdestination"))
    {
	ret["iso-directory"]	=
	    ret["preferences",0,"defaultdestination",0,content_key]:"";
    }

    if (haskey (ret["preferences",0]:$[], "locale"))
    {
	// remove .UTF-8 endings from locale (bnc#675101)
	string lang	= get_preferences (ret, "locale", "");
	list<string> split = splitstring (lang, ".");
	ret	= save_preferences (ret, "locale", split[0]:lang);
    }
    return ret;
  }

  /**
   * Write currect configuration to new config.xml
   */
  global boolean WriteConfigXML (map<string,any> KiwiConfig, string task) {

    all_sources		= Pkg::SourceEditGet();
    tmp_dir		= Directory::tmpdir;
    chroot_dir		= tmp_dir + "/myphysical";
    string defaultroot	= get_preferences (KiwiConfig, "defaultroot", "");
    if (defaultroot != "")
    {
	chroot_dir	= defaultroot;
	if (KiwiConfig["new_configuration"]:false)
	    chroot_dir	= chroot_dir + "/" + KiwiConfig["name"]:"";
	KiwiConfig	= save_preferences(KiwiConfig,"defaultroot",chroot_dir);
    }

    string image_tag	= sformat ("<image name=\"%1\" schemaversion=\"%2\"%3>",
	KiwiConfig["name"]:"", KiwiConfig["schemaversion"]:"5.2",
	(KiwiConfig["inherit"]:"" == "" ?
	    "" :
	    sformat (" inherit=\"%1\"", KiwiConfig["inherit"]:"")
	)
    );
    string image_contents	=
	MapAny2XML ("description", KiwiConfig["description",0]:$[], 1) + "\n" +
	MapAny2XML ("preferences", KiwiConfig["preferences",0]:$[], 1) + "\n";

    if (haskey (KiwiConfig, "users"))
    {
	foreach (map gmap, KiwiConfig["users"]:[], {
	    gmap["user"] = maplist (map umap, (list<map>) gmap["user"]:[], {
		boolean encrypted	= umap["encrypted"]:false;
		umap["pwd"]	= (umap["encrypted"]:false) ?
		    umap["pwd"]:"" :
		    crypt_password (umap["pwd"]:"");
		if (haskey (umap, "encrypted"))
		    umap	= remove (umap, "encrypted");
		return umap;
	    });
	    image_contents	= image_contents +
		MapAny2XML ("users", gmap, 1) + "\n";
	});
    }
    if (size (KiwiConfig["profiles"]:[]) > 0)
    {
	image_contents	= image_contents +
	    MapAny2XML ("profiles", KiwiConfig["profiles",0]:$[], 1) + "\n";
    }
    foreach (string source, KiwiConfig["sources"]:[], {
	map sourcemap	= get_source_value (source, KiwiConfig);
	image_contents	= image_contents +
	    MapAny2XML ("repository", sourcemap, 1) + "\n";
    });
    foreach (map packagemap, KiwiConfig["packages"]:[], {
	if (size (packagemap["opensusePattern"]:[]) == 0 &&
	    size (packagemap["package"]:[]) == 0)
	{
	    y2milestone ("no patterns/packages in %1", packagemap);
	}
	image_contents	= image_contents +
	    MapAny2XML ("packages", packagemap, 1) + "\n";
    });

    // now, add the rest, created using more generic MapAny2XML function
    if (haskey (KiwiConfig, "split") && size (KiwiConfig["split"]:[]) > 0)
    {
	image_contents	= image_contents +
	    MapAny2XML ("split", KiwiConfig["split",0]:$[], 1) + "\n";
    }
    string write_string	= sformat ("<?xml version=\"1.0\"?>
%1
%2</image>", image_tag, image_contents);


    config_dir	= tmp_dir + "/" + KiwiConfig["original_directory"]:KiwiConfig["name"]:"";
    SCR::Execute (.target.mkdir, config_dir);
    SCR::Write (.target.string, config_dir + "/config.xml", write_string);
    // config.xml may contain password, do not let other users read it
    SCR::Execute (.target.bash, sformat ("chmod 600 %1/config.xml",config_dir));

    foreach (string dir, ["root_dir", "config_dir"], {
	foreach (string val, KiwiConfig[dir]:[], {
	    string realdir	= config_dir + "/" + substring (dir, 0, search (dir, "_"));
	    boolean created	= false;
	    if (val != "" && FileUtils::Exists (val))
	    {
		if (!created && !FileUtils::Exists (realdir))
		{
		    SCR::Execute (.target.mkdir, realdir);
		    created	= true;
		}
		SCR::Execute (.target.bash, sformat ("cp -ar %1 %2/", val, realdir));
	    }
	});
    });
    foreach (string file, ["images.sh", "config.sh", "root/build-custom" ], {
	if (KiwiConfig[file]:"" != "")
	{
	    SCR::Write (.target.string, config_dir + "/" + file, KiwiConfig[file]:"");
	    SCR::Execute (.target.bash, "chmod +x " + config_dir + "/" + file);
	}
    });
    foreach (string file, KiwiConfig["import_files"]:[], {
	y2milestone ("copying %1 to %2", file,config_dir);
	SCR::Execute (.target.bash, sformat ("cp -ar %1 %2/", file,config_dir));
    });
    return true;
  }

  // for a given full path to directory, return the path one level up
  // (/a/b/c -> /a/b)
  string path_to_dir (string full_path) {
    // first, leave '/' from the end of string
    string adapted = "/" + mergestring (
	filter (string p, splitstring (full_path, "/"), ``(p != "")),"/"
    );
    return substring (full_path, 0, findlastof (full_path, "/"));
  }

  // wait until process is really done or kill -9 it after minute
  void give_kiwi_time_to_finish (integer pid) {
    integer count = 0;
    while (SCR::Read(.process.running, pid) == true)
    {
	sleep(100);
	count = count + 1;
	if (count > 600) break;
    }
    if (SCR::Read(.process.running, pid) == true) SCR::Execute (.process.kill, pid);
  }

  /**
   * ask user where to save kiwi log files
   */
  boolean save_logs_popup () {

    string dir	= logs_directory;

    UI::OpenDialog (`opt(`decorated), `HBox(`HSpacing(1.5), `VBox (
	`VSpacing (0.2),
	`HBox (
	    // text box label
	    `InputField (`id (`out_dir), `opt (`hstretch), _("Path to directory to store the log files"), dir),
	    `VBox (
		`Label (""),
		`PushButton (`id (`browse), Label::BrowseButton ())
	    )
	),
	// text box label
	`InputField (`id (`stdout_file), `opt (`hstretch), _("Standard output file name"), stdout_file),
	// text box label
	`InputField (`id (`stderr_file), `opt (`hstretch), _("Error output file name"), stderr_file),
	`VSpacing (0.2),
	`ButtonBox (
	    `PushButton (`id (`ok), Label::SaveButton ()),
	    `PushButton (`id (`cancel), Label::CancelButton ())
	),
	`VSpacing (0.2)
    ), `HSpacing(1.5)));

    any ret = `cancel;
    string full_stdout	= dir + "/" + stdout_file;
    string full_stderr	= dir + "/" + stderr_file;

    while (true)
    {
	ret = UI::UserInput ();
	if (ret == `cancel)
	{
	    UI::CloseDialog ();
	    break;
	}
	if (ret == `browse)
	{
	    dir	= (string) UI::QueryWidget (`id (`out_dir), `Value);
	    string selected = UI::AskForExistingDirectory (dir, "");
            if (selected != nil)
		UI::ChangeWidget (`id(`out_dir), `Value, selected);
	}
	if (ret == `ok)
	{
	    dir	= (string) UI::QueryWidget (`id (`out_dir), `Value);
	    full_stdout	= dir + "/" + (string) UI::QueryWidget (`id (`stdout_file), `Value);
	    full_stderr	= dir + "/" + (string) UI::QueryWidget (`id (`stderr_file), `Value);
	    if (FileUtils::Exists (full_stdout) &&
		!Popup::YesNo (sformat (_("File %1 already exists.
Rewrite?"), full_stdout)))
		continue;
	    if (FileUtils::Exists (full_stderr) &&
		!Popup::YesNo (sformat (_("File %1 already exists.
Rewrite?"), full_stderr)))
		continue;
	    break;
	}
    }

    if (ret == `cancel) return false;

    stdout_file	= (string) UI::QueryWidget (`id (`stdout_file), `Value);
    stderr_file	= (string) UI::QueryWidget (`id (`stderr_file), `Value);


    UI::CloseDialog ();

    if (FileUtils::CheckAndCreatePath (dir))
	SCR::Write (.target.string, full_stdout, (string) UI::QueryWidget (`id (`log), `Value));
    else return false;

    SCR::Write (.target.string, full_stderr, (string) UI::QueryWidget (`id (`errlog), `Value));

    logs_directory = dir;

    return true;
  }

  /**
   * run kiwi to finally create the selected image
   * @param out_dir output directory for the result
   * @param selected_profiles which profiles should be build (prepared part
   * of command line option)
   */
  global boolean PrepareAndCreate (string out_dir, string selected_profiles) {

    if (config_dir == "" || !FileUtils::Exists (config_dir))
	return false;
    if (!Package::Install ("kiwi"))
    {
	Report::Error (Message::CannotContinueWithoutPackagesInstalled ());
	return false;
    }

    if (FileUtils::Exists (chroot_dir))
    {
	y2milestone ("%1 directory is present, removing...", chroot_dir);
	map out = (map) SCR::Execute (.target.bash_output, sformat ("rm -rf %1", chroot_dir));
	if (out["exit"]:0 != 0)
	{
	    y2warning ("cmd output: %1", out);
	    Report::Error (_("Removing old chroot directory failed.") + "\n\n" + out["stderr"]:"");
	    return false;
	}
    }
    // create path to chroot_dir if it does not exist (#406731)
    FileUtils::CheckAndCreatePath (path_to_dir (chroot_dir));
    // construct the dialog
    UI::OpenDialog(`opt(`decorated), `HBox(`HSpacing(1.5),
    `VBox(
        `HSpacing(85),
	`VWeight (2, `VBox (
	    `VSpacing(0.5),
	    `ReplacePoint (`id (`rpl),
		// label
		`Left (`Label(_("Preparing for Image Creation")))
	    ),
	    `VSpacing(0.5),
	    `LogView (`id (`log), "", 8, 0)
	)),
	`VWeight (1, `VBox (
	    `VSpacing(0.5),
	    `LogView (`id (`errlog), "", 8, 0),
	    `VSpacing(0.5),
	    `HBox (
		`ReplacePoint (`id (`rp),
		    `PushButton (`id(`cancel),`opt(`key_F9), Label::CancelButton ())
		),
		// button label
		`PushButton (`id(`save), _("Save logs"))
	    ),
	    `VSpacing(0.5)
	))
    ), `HSpacing(1.5)
    ));

    UI::ChangeWidget (`id (`save), `Enabled, false);

    integer id	= -1;

    void update_output () {

	string line = (string)SCR::Read (.process.read_line, id);
	if (line != nil && line != "")
	    UI::ChangeWidget (`id(`log), `LastLine, line + "\n");
	string err = (string)SCR::Read (.process.read_line_stderr, id);
	if (err!= nil && err != "")
	    UI::ChangeWidget (`id(`errlog), `LastLine, err + "\n");
    }

    string linux32	= "";
    string target_arch  = ""; // rather set target_arch only in one specific case
    if (Arch::architecture () == "x86_64" && ProductCreator::GetArch () == "i386")
    {
	linux32		= "linux32";
    }
    if (ProductCreator::GetArch () == "i386" && target_i586)
    {
        target_arch     = "--target-arch i586";
    }
    string cmd	= sformat ("ZYPP_READONLY_HACK=1 %3 kiwi --nocolor --root %1 --prepare %2 --logfile terminal %4", chroot_dir, config_dir, linux32, target_arch);
    if (selected_profiles != "" && selected_profiles != nil)
	cmd = cmd + selected_profiles;

    y2milestone ("calling '%1'", cmd);

    id	= (integer) SCR::Execute (.process.start_shell, cmd);

    symbol ret		= nil;
    boolean creating	= false;
    do
    {
	ret = (symbol) UI::PollInput();
	if (SCR::Read(.process.running, id) != true)
	{
	    update_output ();
	    // explicitely check the process buffer after exit (bnc#488799)
	    string buf   = (string) SCR::Read (.process.read, id);
	    string err_buf	= (string) SCR::Read (.process.read_stderr, id);
	    if (buf != nil && buf != "")
		UI::ChangeWidget (`id(`log), `LastLine, buf + "\n");
	    if (err_buf != nil && err_buf != "")
		UI::ChangeWidget (`id(`errlog), `LastLine, err_buf + "\n");

	    integer status	= (integer) SCR::Read (.process.status, id);
	    if (status != 0)
	    {
		UI::ReplaceWidget (`id (`rp), `HBox (
		    // label (command result)
		    `Label (`opt (`boldFont), _("Image creation failed.")),
		    `PushButton (`id(`close), Label::CloseButton ())
		));
		UI::ChangeWidget (`id (`save), `Enabled, true);
		repeat
		{
		    ret	= (symbol) UI::UserInput ();
		    if (ret == `save) save_logs_popup ();
		} until (ret == `close);
		break;
	    }
	    else if (!creating)
	    {
		creating	= true;
		SCR::Execute (.process.kill, id); // just to be sure...

		// now continue with creating
		UI::ChangeWidget (`id(`log), `LastLine, "\n");
		cmd	= sformat ("ZYPP_READONLY_HACK=1 %3 kiwi --nocolor --create %1 -d %2 --logfile terminal %4",
		    chroot_dir, out_dir, linux32, target_arch);
		y2milestone ("calling '%1'", cmd);
		// label
		UI::ReplaceWidget (`id (`rpl), `Left (`Label (_("Creating Image"))));
		id	= (integer) SCR::Execute (.process.start_shell, cmd);
		ret	= nil;
		continue;
	    }
	    else
	    {
		UI::ReplaceWidget (`id (`rp), `HBox (
		    // label (command result)
		    `Label (`opt (`boldFont), _("Image creation succeeded.")),
		    `PushButton (`id(`ok), Label::OKButton ())
		));
		UI::ChangeWidget (`id (`save), `Enabled, true);
		repeat
		{
		    ret	= (symbol) UI::UserInput ();
		    if (ret == `save) save_logs_popup ();
		} until (ret == `ok);
		break;
	    }
	}
	else
	{
	    update_output ();
	}
	if (ret == `cancel)
	{
	    UI::ReplaceWidget (`id (`rp), `HBox (
		// label (command result)
		`Label (`opt (`boldFont), _("Image creation canceled.")),
		`PushButton (`id(`close), Label::CloseButton ())
	    ));
	    SCR::Execute (.process.kill, id, 15);
	    give_kiwi_time_to_finish (id);
	    UI::ChangeWidget (`id (`save), `Enabled, true);
	    repeat
	    {
		ret	= (symbol) UI::UserInput ();
		if (ret == `save)
		    save_logs_popup ();
	    } until (ret == `close);
	    break;
	}
	sleep (100);
    } while (ret == nil);

    give_kiwi_time_to_finish (id);

    UI::CloseDialog ();
    return ret == `ok;
  }

  /**
   * save the image configuration to the kiwi images directory
   */
  global string SaveConfiguration (map KiwiConfig, string task) {
    if (config_dir == "" || !FileUtils::Exists (config_dir))
	return nil;
    if (!FileUtils::Exists (images_dir))
	SCR::Execute (.target.mkdir, images_dir);
    SCR::Execute (.target.bash, sformat ("cp -ar %1 %2/", config_dir, images_dir));
    return (images_dir + "/" + KiwiConfig["name"]:"");
  }

    /**
     * Import repositories from given kiwi image configuration
     * @patam Config configuration map, as read from config.xml
     * @param dir path to directory containing this config.xml
     */
    global map <string,map> ImportImageRepositories (map Config, string dir) {

	current_repositories	= $[];
	foreach (map repo, (list<map>) Config["repository"]:[], {
	    string source	= repo["source",0,"path"]:"";
	    if (source != "")
	    {
		string url	= "";
		if (substring (source, 0, 7) == "this://")
		{
		    string source_path = substring (source, 7);
		    source	= dir + "/" + source_path;
		}
		if (substring (source, 0, 1) == "/")
		    url	= "dir://";
		url	= url + source;
		map parsed      = URL::Parse (url);
		string full_url	= url;
		if (parsed["pass"]:"" != "")
		{
		    parsed      = remove (parsed, "pass");
		    url         = URL::Build (parsed);
		}
		current_repositories	[url]	= $[
		    "url"	: url,
		    "plaindir"	: repo["type"]:"" == "rpm-dir",
		    "org"	: repo,
		    "full_url"	: full_url
		];
	    }
	});
	return current_repositories;
    }

   /**
    * Initialize the list of current repositories
    */
   global map <string,map> InitCurrentRepositories () {

	current_repositories	= $[];
	Pkg::SourceRestore ();
	foreach (map source, Pkg::SourceEditGet (), {
	    integer srcid       = source["SrcId"]:-1;
	    map data = Pkg::SourceGeneralData (srcid);
	    string url	= data["url"]:"";
	    string full_url	= url;
	    map parsed = URL::Parse(url);
	    if (parsed["scheme"]:"" == "https")
		full_url	= Pkg::SourceURL (srcid);
	    current_repositories[url]	= $[
		"url"		: url,
		"plaindir"	: data["type"]:"" == "Plaindir",
		"full_url"	: full_url,
	    ];
	});
	return current_repositories;
   }

  /**
   * Read the templates on which the images can be based
   */
  global boolean ReadImageTemplates () {

    string dirs = (string)SCR::Read(.sysconfig.product-creator.IMAGE_TEMPLATES);
    map name_version	= $[];
    foreach (string line, splitstring (dirs, "\t "), {
	if (line == "" || substring (line, 0, 1) == "#")
	    return;
	templates_dirs	= add (templates_dirs, line);
	if (!FileUtils::IsDirectory (line))
	{
	    y2warning ("%1 is not a directory", line);
	    return;
	}
	map out = (map) SCR::Execute (.target.bash_output,
	    sformat ("ls -A1 %1", line));
	foreach (string d, splitstring(out["stdout"]:"", "\n"), {
	    if (d == "") return;
	    map config	= Kiwi::ReadConfigXML (line + "/" + d);
	    // index by full path, there may be same names
	    // (templates could be provided by different vendors)
	    if (config != nil && config != $[])
	    {
		string name	= config["name"]:"";
		string ver	= get_preferences (config, "version", "");
		if (config["description",0,"type"]:"" != "system")
		    y2warning ("%1 not a 'system' image type, skipping", name);
		else if (name_version[name]:nil == ver)
		    y2warning ("template %1,%2 already imported", name, ver);
		else
		{
		    name_version[name]	= ver;
		    Templates[line + "/" + d]	= config;
		}
	    }
	});
    });
    return true;
  }

  /**
   * REad the confgiuration stuff for image creator
   */
  global boolean Read () {

    string dir =
	(string) SCR::Read (.sysconfig.product-creator.IMAGE_CONFIGURATIONS);
    if (dir != nil && dir != "")
	images_dir	= dir;
    supported_boot_images	=
	(string) SCR::Read (.sysconfig.product-creator.SUPPORTED_BOOT_IMAGES);
    if (supported_boot_images == nil)
	supported_boot_images	= "";
    string architecture	=
	(string) SCR::Read (.sysconfig.product-creator.DEFAULT_IMAGE_ARCHITECTURE);
    if (architecture == "" || architecture == nil)
	architecture	= ProductCreator::GetArch ();
    if (architecture != "x86_64") // all i[456]86 are i386...
	architecture	= "i386";
    image_architecture	= architecture;
    return ReadImageTemplates ();
  }
}

