/**
 * File:	modules/ProductCreator.ycp
 * Package:	Configuration of product-creator
 * Summary:	Data for configuration of product-creator, input and output functions.
 * Authors:	Anas Nashif <nashif@suse.de>
 *
 * $Id$
 *
 * Representation of the configuration of product-creator.
 * Input and output routines.
 */

{

module "ProductCreator";
textdomain "product-creator";

import "AddOnCreator";
import "Progress";
import "Report";
import "Summary";
import "XML";
import "URL";
import "Profile";
import "Misc";
import "Directory";
import "Profile";
import "AutoinstSoftware";
// NOTE: do not use Arch:: directly in this module, use GetArch() function instead!
import "Arch";
import "Package";
import "PackageAI";
import "Popup";
import "String";
import "SourceManager";
import "GPG";
import "GPGWidgets";
import "Mode";
import "CommandLine";
import "FileUtils";
import "PackageCallbacks";


global define void enableSources();
global define integer checkProductDependency();
global define boolean readControlFile(string filename);
global define boolean EnableSource();

list<integer> old_enabled = [];

// content file cache - avoid multiple content file downloading
map<integer, map<string,string> > content_cache = $[];

global string AYRepository = "";

global map meta = $[];
global map meta_local = $[];

global list<string> missing_packages = [];

// packages to copy
// $[ source_id : $[ media_id : list<packages> ] ]
map<integer, map<integer, list<map> > > toCopy = $[];

/* Local variables */

global string skel_root = "";


global boolean profile_parsed = false;

global integer max_size_mb	= 999 * 1024;

/* Configuration Map */
global map<string, any> Config = $[];

/* All Configurations */
global map<string, map<string, any> > Configs = $[];

/* Configuration Repository */
global string Rep = "/var/lib/YaST2/cd-creator";

/* Configuration file */
global string ConfigFile = Rep + "/cdcreator.xml";

global string gpg_passphrase = "";

map<string,map> pattern_descr	= nil;


/**
 * Abort function
 * return boolean return true if abort
 */
global block<boolean> AbortFunction = nil;


/*
  Target architecture
  Initialized to the current architecture
*/

// forward declaration
string ToPackageArch(string arch);

// default is the system architecture
string _arch = nil;

string ToPackageArch(string arch)
{
    if (arch == "s390_64")
    {
	arch = "s390x";
    }
    if (arch == "s390_32")
    {
	arch = "s390";
    }

    if (!contains(["i386", "i486", "i586", "i686", "sparc", "sparc64", "mips", "mips64", "ppc", "ppc64", "alpha", "s390", "s390x", "ia64", "x86_64"], arch))
    {
	y2error("Unknown architecture '%1'!", arch);
	return nil;
    }

    return arch;
}

/**
  Set the target package architecture
  @param new_arch new architecture (i386, i486, i586, i686, sparc, sparc64, mips, mips64, ppc, ppc64, alpha, s390, s390x, ia64, x86_64)
  @return true on success
*/
global boolean SetPackageArch(string new_arch)
{
    string pkgarch = ToPackageArch(new_arch);

    if (pkgarch == nil)
    {
	return false;
    }

    _arch = pkgarch;
    y2milestone("Target architecture set to '%1'", new_arch);

    // set the architecture in the package manager
    Pkg::SetArchitecture(_arch);

    return true;
}

// convert package (like i686) arch to system arch (i386)
global string GetArch()
{
    string ret = _arch;

    // not set, use the current arch
    if (ret == nil)
    {
	ret = Arch::architecture();
    }

    // convert x86 package archs to i386 system arch
    if (contains(["i486", "i586", "i686"], ret))
    {
	ret = "i386";
    }
    else if (ret == "s390_64")
    {
	ret = "s390x";
    }
    else if (ret == "s390_32")
    {
	ret = "s390";
    }

    return ret;
}

// nil means not set
global string GetPackageArch()
{
    return _arch;
}

global void ResetArch()
{
    _arch = nil;

    if (Pkg::GetArchitecture() != Pkg::SystemArchitecture())
    {
	// set the system architecture in the package manager
	y2milestone("Resetting the target architecture to '%1'", Pkg::SystemArchitecture());
	Pkg::SetArchitecture(Pkg::SystemArchitecture());
    }
}


/**
 * Data was modified?
 */
global boolean modified = false;

global boolean proposal_valid = false;

// if the YaST sources should be enabled when opening package selector
global boolean enable_sources	= true;

// original source configuration, needed to reset the package manager
list<map<string,any> > original_config = nil;

boolean gzip_is_installed	= nil;

boolean gzip_installed () {
    if (gzip_is_installed == nil)
	gzip_is_installed = Package::Installed ("gzip");
    return gzip_is_installed;
}

/**
 * Data was modified?
 * @return true if modified
 */
global define boolean Modified() ``{
    y2debug("modified=%1",modified);
    return modified;
};

/**
 * Abort function
 * @return blah blah lahjk
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
	return eval(AbortFunction) == true;
    return false;
}

/**
 * Check for pending Abort press
 * @return true if pending abort
 */
global define boolean PollAbort() ``{
    return UI::PollInput() == `abort;
}

/**
 * If modified, ask for confirmation
 * @return true if abort is confirmed
 */
global define boolean ReallyAbort() ``{
    return !ProductCreator::Modified() || Popup::ReallyAbort(true);
}

/**
 * Progress::NextStage and Progress::Title combined into one function
 * @param title progressbar title
 */
define void ProgressNextStage(string title) ``{
    Progress::NextStage();
    Progress::Title(title);
}




// set the packages to 'taboo' state
global void MarkTaboo(list<string> packages_taboo)
{
    // remove packages (set to taboo)
    if (packages_taboo != nil && size(packages_taboo) > 0)
    {
	foreach(string p, packages_taboo,
	    {
		y2milestone("marking taboo package: %1 -> %2", p, Pkg::PkgTaboo(p));
	    }
	);
    }
}


symbol autoyastPackages ()
{
    string base_selection = "";
    // busy message
    string feedback	= _("Reading data from Package Database...");
    if (Mode::commandline())
	CommandLine::PrintVerbose (feedback);
    else
	// popup
	Popup::ShowFeedback (feedback, _("Please wait..."));

    Pkg::TargetFinish ();
    string tmp = (string)SCR::Read( .target.tmpdir );
    SCR::Execute(.target.mkdir, tmp + "/tmproot");
    Pkg::TargetInit( tmp + "/tmproot" , true);

    boolean  success =  ProductCreator::EnableSource();

    // Pkg::SourceStartManager(true);

    if (ProductCreator::Config["profile"]:""!= "" && ! ProductCreator::profile_parsed)
    {
	if(!ProductCreator::readControlFile(ProductCreator::Config["profile"]:""))
	    return `overview;
	// set the new selection
	y2debug("Config: %1", ProductCreator::Config );

	if (ProductCreator::Config["type"]:`unknown == `patterns)
	{
	    string base_pat = ProductCreator::Config["base"]:"";

	    if (size(base_pat) > 0)
	    {
		Pkg::ResolvableInstall(base_pat, `pattern);
		y2milestone("Selecting pattern: %1", base_pat);
	    }

	    if (size(ProductCreator::Config["addons"]:[]) > 0)
	    {
		foreach(string addon, ProductCreator::Config["addons"]:[], ``{
			Pkg::ResolvableInstall(addon, `pattern);
			y2milestone("Selecting pattern: %1", addon);
		});
	    }
	}
	else
	{
	    boolean pkgret = Pkg::SetSelection( ProductCreator::Config["base"]:"" );

	    foreach(string addon, ProductCreator::Config["addons"]:[], ``{
		    Pkg::SetSelection( addon );
		    });
	}

	if (size(ProductCreator::Config["packages"]:[] ) > 0)
	{
	    foreach(string p, ProductCreator::Config["packages"]:[], ``{
		    y2milestone("selecting package for installation: %1 -> %2", p, Pkg::PkgInstall(p));
		    });
	}

	// mark taboo packages
	MarkTaboo(ProductCreator::Config["taboo"]:[]);

	Pkg::PkgSolve(true);

	list allpacs = Pkg::GetPackages(`selected, true);
	y2milestone("All packages: %1 ( %2 )", allpacs, size(allpacs));
    }
    Popup::ClearFeedback();
    return `next;
}

global boolean LoadConfig(string config_name)
{
    ProductCreator::Config = ProductCreator::Configs[config_name]:$[];

    return haskey(ProductCreator::Configs, config_name);
}

global void CommitConfig()
{
    if (ProductCreator::Config["profile"]:""!="")
	autoyastPackages();

    string name = ProductCreator::Config["name"]:"";
    string old_name = ProductCreator::Config["old_name"]:"";

    if (haskey(ProductCreator::Configs, old_name) && old_name != "")
    {

	ProductCreator::Configs = filter(string k, map<string,any> v, ProductCreator::Configs, ``(k!=old_name));
	remove(ProductCreator::Config, "old_name");
    }

    ProductCreator::Configs[name] = ProductCreator::Config;
}


global integer PackageCount()
{
    integer ret = 0;

    foreach(integer source, map<integer, list<map> > srcmapping, toCopy,
	{
	    foreach(integer medium, list<map> packages, srcmapping,
		{
		    ret = ret + size(packages);
		}
	    );
	}
    );

    return ret;
}


global define list<integer> UrlToId(list<string> urls)
{
    // all sources
    list<integer> all = Pkg::SourceGetCurrent(false);

    list<integer> sources = maplist(string url , urls,
    {
	integer id = -1;
	foreach (integer i, all,
	{
	    map generalData = Pkg::SourceGeneralData(i);
	    if (generalData["url"]:"" == url)
	    {
		id = i;
		break;
	    }
	});

	if (id == -1)
	{
	    y2error("Source %1 not found!", url);
	}

	return id;
    });

    y2milestone("URL to repoid: %1 -> %2", urls, sources);

    return sources;
}


global map<string,string> ReadContentFile(integer srcid) {
    if (haskey(content_cache, srcid))
    {
	return content_cache[srcid]:$[];
    }

    // make content file optional (for empty repos, bnc#500527)
    string content = Pkg::SourceProvideOptionalFile(srcid, 1, "content");
    map<string,string> contentmap = (map<string,string>)SCR::Read(.content_file, content);
    if (contentmap == nil)
	contentmap	= $[];
    content_cache[srcid] = contentmap;
    y2debug("content_cache: %1", content_cache);

    return contentmap;
}


/**
 * Read all product-creator settings
 * @return true on success
 */
global define boolean Read() ``{

    /* ProductCreator read dialog caption */
    string caption = _("Initializing Product Creator Configuration");

    integer steps = 1;

    integer sl = 2;
    sleep(sl);

    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    // translators: progress stage 1/1
	    _("Read the configuration")
	], [
	    // translators: progress step 1/1
	    _("Reading the database..."),
	    // translators: progress finished
	    _("Finished")
	],
	""
    );

    // read database
    if(Abort()) return false;
    Progress::NextStage();

    map c = $[];
    if (SCR::Read(.target.size, ConfigFile) != -1 )
    {
	c = XML::XMLToYCPFile(ConfigFile);
    }
    list<map<string, any> > all = c["configurations"]:[];
    Configs = listmap (map<string,any> i, all, ``{
	string name = i["name"]:"";
	return($[name: i]);
    });
    y2milestone("Configs: %1", Configs);

    // translators: error message
    if(false) Report::Error(_("Cannot read the configuration."));
    sleep(sl);


    if(Abort()) return false;
    // translators: progress finished
    ProgressNextStage(_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    modified = false;
    return true;
}



/**
 * Prepare map for writing  into XML
 * @return lists of configurations
 */
global define list PrepareConfigs() ``{

    list c = maplist(string k, map v, Configs, ``{

	list<string> sources = v["sources"]:[];

	// escape XML entities in URL
	// (e.g. iso:///?iso=image.iso&url=file:///local/images/ cannot be stored by the XML agent)
	if (size(sources) > 0)
	{
	    sources = maplist(string src, sources,
		{
		    return String::EscapeTags(src);
		}
	    );

	    v["sources"] = sources;
	}
	string base_repo	= v["base_repo"]:"";
	if (base_repo != "")
	{
	    v["base_repo"]	= String::EscapeTags (base_repo);
	}

	return(v);
    });
    return (c);
}

/**
 * Write all product-creator settings
 * @return true on success
 */
global define boolean Write() ``{

    /* ProductCreator read dialog caption */
    string caption = _("Saving Product Creator Configuration");

    integer steps = 2;

    integer sl = 50;
    sleep(sl);

    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    // translators: progress stage 1/2
	    _("Write the settings"),
	], [
	    // translators: progress step 1/1
	    _("Writing the settings..."),
	    // translators: progress finished
	    _("Finished")
	],
	""
    );

    // write settings
    if(Abort()) return false;
    Progress::NextStage();

    list c = PrepareConfigs();
    map xml = $["configurations": c];

    if (SCR::Read(.target.size, Rep) < 0)
    {
	SCR::Execute(.target.bash, "mkdir -p " + Rep);
    }

    y2milestone("Writing XML file %1: %2", ConfigFile, xml);
    boolean ret = XML::YCPToXMLFile(`cdcreator, xml, ConfigFile);

    // translators: error message
    if(!ret) Report::Error (_("Error while writing settings."));


    // run SuSEconfig
    if(Abort()) return false;
    Progress::NextStage ();
    // translators: error message
    if(false) Report::Error (_("SuSEconfig script failed."));
    sleep(sl);

    if(Abort()) return false;
    // translators: progress finished
    ProgressNextStage(_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    return true;
}

/**
 * Get all product-creator settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global define boolean Import (map settings) ``{
    return true;
}

/**
 * Dump the product-creator settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global define map Export () ``{
    return $[];
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global define list Summary() ``{
    // translators: Configuration summary text for autoyast
    return [ _("Configuration summary ..."), [] ];
}

/**
 * Create an overview table with all configured cards
 * @return table items
 */
global define list Overview() ``{
    y2milestone("Configs: %1", Configs);
    list overview = maplist(string name , map cfg, Configs , ``{
            string isofile = cfg["iso-directory"]:"" + "/" +  cfg["isofile"]:"";
            if (SCR::Read(.target.size, isofile) < 0 )
                isofile = _("No Files");
	return(`item(`id(name), name, cfg["product"]:"", isofile, cfg["gpg_key"]:""));
    });
    return overview;
}


/**
 * Get media urls
 * @param list list of ids
 * @return list list of urls
 */
global define list getSourceURLs ( list<integer> ids ) ``{
    list<string> urls = maplist(integer i , ids, ``{
	map media = Pkg::SourceGeneralData(i);

	return(media["url"]:"");
    });

    return urls;
}


/**
 * get path to directory source
 * @param string url
 * @return string path
 */
global define string getSourceDir(string url) ``{
    map urlsegs = URL::Parse(url);
    return(urlsegs["path"]:"");
}

/**
 * Return contents of isolinux.cfg from the given source
 * @return string with contents of file.
 */
global define string Readisolinux() ``{

    string bootconfig = Config["bootconfig"]:"";
    if (bootconfig != "")
    {
	return bootconfig;
    }

    string bootconfig_path = "";
    if (Config["pkgtype"]:"" == "autoyast")
    {
        bootconfig_path = sformat("%1/product-creator/isolinux.cfg",
                Directory::datadir);
    }
    else
    {
	string arch = GetArch();
	if (arch == "s390_64") arch = "s390x";
	bootconfig_path = sformat("boot/%1/loader/isolinux.cfg", arch);


	list<integer> srcids	= [];
	// bnc#496263
	if (Config["base_repo"]:"" == "")
	    srcids = [checkProductDependency()];
	else
	    srcids	= UrlToId ([Config["base_repo"]:""]);

	foreach(integer srcid, srcids,
	    {
		y2milestone("Downloading %1 from source %2", bootconfig_path, srcid);
		bootconfig_path = Pkg::SourceProvideOptionalFile(srcids[0]:0, 1, bootconfig_path);
		y2debug ("bootconfig_path: %1", bootconfig_path);

		if (bootconfig_path == nil)
		{
		    // try the old path as a fallback
		    bootconfig_path = "boot/loader/isolinux.cfg";
		    bootconfig_path = Pkg::SourceProvideOptionalFile(srcids[0]:0, 1, bootconfig_path);
		    y2debug("bootconfig_path: %1", bootconfig_path);

		    if (bootconfig_path != nil)
		    {
			break;
		    }
		}
		else
		{
		    y2milestone("Found bootconfig in source %1", srcid);
		    break;
		}
	    }
	);
    }
    if (SCR::Read(.target.size, bootconfig_path) >= 0)
          bootconfig = (string)SCR::Read(.target.string, bootconfig_path );
    else
    {
	y2error("cannot read file %1", bootconfig_path);
    }


    // replace tabs by spaces in ncurses UI (workaround for #142509)
    if (UI::GetDisplayInfo()["TextMode"]:false == true)
    {
	// tab -> 8 spaces
	bootconfig = String::Replace(bootconfig, "\t", "        ");
    }

    return bootconfig;
}

/**
 * Create XML Configuration
 */
global define void configSetup()
    ``{
    map doc = $[];
    doc["listEntries"] =
	$[
	  "packages":"package",
	  "addons":"addon",
	  "configurations": "config"
	];
    doc["cdataSections"] = ["bootconfig"];
    doc["rootElement"] = "product-creator";
    doc["systemID"] = "/usr/share/autoinstall/dtd/product-creator.dtd";
    doc["nameSpace"] = "http://www.suse.com/1.0/yast2ns";
    doc["typeNamespace"] = "http://www.suse.com/1.0/configns";
    XML::xmlCreateDoc(`cdcreator, doc);
    return;
}

boolean ExportPublicKey(string keyid, string dir)
{
    y2debug("ExportPublicKey: %1 to %2", keyid, dir);
    // export the public key
    boolean ret = GPG::ExportAsciiPublicKey(keyid, dir + "/content.key");

    // export the public key
    ret = ret && GPG::ExportAsciiPublicKey(keyid, dir + "/media.1/products.key");

    // export the public key
    ret = ret && GPG::ExportAsciiPublicKey(keyid, dir + sformat("/gpg-pubkey-%1.asc", tolower(keyid)));

    y2milestone("exported public key %1: %2", keyid, ret);
    return ret;
}

boolean SignSourceFiles(string keyid, string dir, string passphrase)
{
    // sign the content file
    boolean ret = GPG::SignAsciiDetached(keyid, dir + "/content", passphrase);

    // sign the product file if exists
    if (FileUtils::Exists (dir + "/media.1/products"))
    {
	ret = ret && GPG::SignAsciiDetached(keyid, dir + "/media.1/products", passphrase);
    }

    // sign the add_on_products file
    if (FileUtils::Exists (dir + "/add_on_products"))
    {
	ret = ret && GPG::SignAsciiDetached(keyid, dir + "/add_on_products", passphrase);
    }

    y2milestone("Signed source: %1", ret);
    return ret;
}

string SHA1Meta(string dir, string product_dir)
{
    // generate new sha1 sums for files in descr subdirectory
    // remove './' from the file names, ignore directory.yast file, sort the output
    string command = sformat("(cd '%1/%2' && find . -type f -exec sha1sum \\{\\} \\; | sed -e 's#^\\(.\\{40\\}\\)  ./#META SHA1 \\1  #' | grep -v '^.\\{40\\}  directory.yast$' | LC_ALL=C sort -k 2)", String::Quote(dir), String::Quote(product_dir));

    y2milestone("Generating SHA1 sums: %1", command);

    // execute the command
    map ret = (map)SCR::Execute(.target.bash_output, command);
    y2milestone("Result: %1", ret);
    string meta_sha1 = ret["stdout"]:"";

    return meta_sha1;
}

string SHA1Key(string dir)
{
    // generate new sha1 sums for files in descr subdirectory
    // remove './' from the file names, ignore directory.yast file, sort the output
    string command = sformat("(cd '%1' && find . -type f -name 'gpg-pubkey-*.asc' -exec sha1sum \\{\\} \\; | sed -e 's#^\\(.\\{40\\}\\)  ./#KEY SHA1 \\1  #' | LC_ALL=C sort -k 2)", String::Quote(dir));

    y2milestone("Generating SHA1 key sums: %1", command);

    // execute the command
    map ret = (map)SCR::Execute(.target.bash_output, command);
    y2milestone("Result: %1", ret);
    string key_sha1 = ret["stdout"]:"";

    return key_sha1;
}

global boolean UpdateContentFile(string dir, string prod_dir)
{
    boolean ret = true;

    string meta_sha1 = SHA1Meta(dir, prod_dir);
    string key_sha1 = SHA1Key(dir);

    // add the sum of add_on_products if it was created
    if (FileUtils::Exists (dir + "/add_on_products"))
    {
	string command = sformat ("cd %1; sha1sum add_on_products", dir);
	y2milestone ("Generating SHA1 sum for add_on_products: %1", command);
	map ret = (map)SCR::Execute(.target.bash_output, command);
	y2milestone("Result: %1", ret);
	meta_sha1	= meta_sha1 + "HASH SHA1 " + ret["stdout"]:"";
    }

    string command = sformat("/usr/bin/grep -v -e '^KEY ' -e '^META ' '%1/content'", String::Quote(dir));
    map out = (map)SCR::Execute(.target.bash_output, command);
    if (out["exit"]:-1 != 0)
    {
	return false;
    }

    string read_content = out["stdout"]:"";
    y2debug("content file: %1", read_content);

    // add trailing new line char if it's missing
    if (size(read_content) > 0 && substring(read_content, size(read_content) - 1, 1) != "\n")
    {
	read_content = read_content + "\n";
    }

    // add trailing new line char if it's missing
    if (size(meta_sha1) > 0 && substring(meta_sha1, size(meta_sha1) - 1, 1) != "\n")
    {
	meta_sha1 = meta_sha1 + "\n";
    }

    // concatenate the meta and the key sums
    read_content = read_content + meta_sha1 + key_sha1;
    y2debug("new content file: %1", read_content);

    // write the file
    ret = SCR::Write(.target.string, dir + "/content", read_content);
    y2milestone("Updated content file %1: %2", dir + "/content", ret);

    return ret;
}

// execute a command
boolean Exec(string command)
{
    y2milestone("executing: %1", command);
    integer ret = (integer)SCR::Execute (.target.bash, command);

    if (ret == 0)
    {
	y2milestone("result: %1", ret);
    }
    else
    {
	y2error("result: %1", ret);
    }

    return ret == 0;
}

global boolean UpdateMD5File(string directory)
{
    string command = sformat("/bin/sh /usr/bin/create_md5sums '%1'", String::Quote(directory));

    if (issubstring (directory, " "))
    {
	command = sformat ("cd '%1'; rm MD5SUMS; md5sum -- * > MD5SUMS",
	    String::Quote(directory));
    }
    boolean ret = Exec(command);

    y2milestone("MD5SUMS updated: %1", ret);

    return ret;
}

boolean CopyFile(integer srcid, integer mid, string src, string target)
{
    string local_file = Pkg::SourceProvideFile(srcid, mid, src);
    y2debug("local_file: %1", local_file);

    return Exec(sformat("/bin/cp -a -f -- '%1' '%2'", String::Quote(local_file), String::Quote(target)));
}

boolean CopyOptionalFile(integer srcid, integer mid, string src, string target)
{
    string local_file = Pkg::SourceProvideOptionalFile(srcid, mid, src);
    y2debug("local_file: %1", local_file);

    if (local_file != nil && local_file != "")
    {
	return Exec(sformat("/bin/cp -a -f -- '%1' '%2'", String::Quote(local_file), String::Quote(target)));
    }
    else
    {
	y2warning("Optional file [%1:%2]%3 is missing", srcid, mid, src);
    }

    return true;
}

boolean CopyDirectoryR(integer srcid, integer mid, string src, string target, boolean optional)
{
    y2milestone("CopyDirectoryRec: srcid: %1, mid: %2, src: %3, target: %4", srcid, mid, src, target);

    string local_dir = Pkg::SourceProvideDirectory(srcid, mid, src, optional, true);
    y2milestone("local_dir: %1", local_dir);

    if (local_dir == nil || local_dir == "")
    {
	if (!optional)
	{
	    // an error message, %1 is the directory, %2 is URL of the source
	    Report::Error(sformat(_("Cannot read directory %1\nfrom source %2."), src, Pkg::SourceGeneralData(srcid)["url"]:""));
	}

	return false;
    }

    return Exec(sformat("/bin/cp -a -f -- '%1' '%2'", String::Quote(local_dir), String::Quote(target)));
}

boolean CopyDirectoryRec(integer srcid, integer mid, string src, string target)
{
    return CopyDirectoryR(srcid, mid, src, target, false);
}

boolean CopyDirectoryRecOpt(integer srcid, integer mid, string src, string target)
{
    return CopyDirectoryR(srcid, mid, src, target, true);
}

list<string> GetList(integer srcid, integer mid, string dir)
{
    // get file list from directory.yast
    string file_list = Pkg::SourceProvideOptionalFile(srcid, mid, sformat("%1/directory.yast", dir));

    if (file_list == nil || file_list == "")
    {
	y2error("directory.yast was not found, a YUM source?");
	return nil;
    }

    string f = (string)SCR::Read(.target.string, file_list);
    list<string> files = splitstring(f, "\n");
    y2milestone("Remote objects: %1", files);

    return files;
}

boolean CopyDirectoryNonRec(integer srcid, integer mid, string src, string target)
{
    // get file list from directory.yast
    list<string> files = GetList(srcid, mid, "");
    if (files == nil)
    {
	files = [];
    }

    files = filter(string file, files, {return !regexpmatch(file, "/$") && file != "";});
    y2milestone("Remote files: %1", files);

    foreach(string remote_file, files,
	{
	    // copy the file as optional, the directory.yast file can be broken
	    CopyOptionalFile(srcid, mid, sformat("%1/%2", src, remote_file), sformat("%1/%2", target, remote_file));
	}
    );

    return true;
}

boolean CopyDocu(integer srcid, string target)
{
    list<string> lst = GetList(srcid, 1, "");
    if (lst == nil)
    {
	lst = [];
    }

    boolean ret = true;

    if (contains(lst, "docu/"))
    {
	y2milestone("Copying /docu subdirectory");
	Exec(sformat("/bin/mkdir -p '%1/docu'", String::Quote(target)));

	boolean r = CopyDirectoryRecOpt(srcid, 1, "/docu", target);

	if (!r)
	{
	    list<string> files = [
		"docu/RELEASE-NOTES.en.html", "docu/RELEASE-NOTES.en.rtf"
	    ];

	    y2milestone("Directory listing may be missing using fixed list: %1", files);

	    foreach(string f, files,
		{
		    CopyOptionalFile (srcid, 1, f, target + f);
		}
	    );
	}

	ret = ret && r;
    }

    return ret;
}

boolean CopyPPCBoot(integer srcid, string target)
{
    y2milestone("Copying PPC boot files");
    boolean ret = true;

    y2milestone("Copying /ppc subdirectory");
    boolean r = CopyDirectoryRecOpt(srcid, 1, "/ppc", target);

    if (!r)
    {
	y2milestone("Directory listing may be missing, copying /ppc/bootinfo.txt");
	CopyFile(srcid, 1, "/ppc/bootinfo.txt", target + "/ppc");
    }

    ret = ret && r;


    y2milestone("Copying /PS3 subdirectory");
    r = CopyDirectoryRecOpt(srcid, 1, "/PS3", target);

    if (!r)
    {
	y2milestone("Directory listing may be missing, copying /ppc/bootinfo.txt");
	Exec(sformat("/bin/mkdir -p '%1/PS3/otheros'", String::Quote(target)));
	CopyOptionalFile(srcid, 1, "/PS3/otheros/otheros.bld", target + "/PS3/otheros");
    }

    ret = ret && r;


    y2milestone("Copying /suseboot subdirectory");
    r = CopyDirectoryRecOpt(srcid, 1, "/suseboot", target);
    y2milestone("Result: %1", r);

    if (!r)
    {
	list<string> files = [
	    "/suseboot/inst32", "/suseboot/inst64", "/suseboot/os-chooser",
	    "/suseboot/yaboot", "/suseboot/yaboot.cnf", "/suseboot/yaboot.ibm",
	    "/suseboot/yaboot.txt"
	];

	y2milestone("Directory listing may be missing using fixed list: %1", files);

	foreach(string f, files,
	    {
		CopyOptionalFile(srcid, 1, f, target + f);
	    }
	);
    }


    y2milestone("Copying /etc subdirectory");
    r = CopyDirectoryRecOpt(srcid, 1, "/etc", target);

    if (!r)
    {
	y2milestone("Directory listing may be missing, copying /etc/yaboot.conf");
	CopyOptionalFile(srcid, 1, "/etc/yaboot.conf", target + "/etc");
    }

    ret = ret && r;

    return ret;
}

string UpDir(string input)
{
    list<string> parts = splitstring(input, "/");

    if (size(parts) < 1)
    {
	return "";
    }

    // remove the last element
    parts = remove(parts, size(parts) - 1);

    return mergestring(parts, "/");
}


boolean CopyFilesRegExp(integer srcid, integer mid, string src, string target, string regexp)
{
    // get file list from directory.yast
    string file_list = Pkg::SourceProvideOptionalFile(srcid, 1, "directory.yast");

    if (file_list == nil || file_list == "")
    {
	y2error("directory.yast was not found, a YUM source?");
	return false;
    }

    string f = (string)SCR::Read(.target.string, file_list);
    list<string> files = splitstring(f, "\n");
    y2milestone("Remote objects: %1", files);

    files = filter(string file, files, {return !regexpmatch(file, "/$") && regexpmatch(file, regexp) && file != "";});
    y2milestone("Remote files: %1", files);


    foreach(string remote_file, files,
	{
	    CopyOptionalFile(srcid, mid, sformat("%1/%2", src, remote_file), sformat("%1/%2", target, remote_file));
	}
    );

    return true;
}

// map additional products to "Addon" directory
map<integer,string> product_map = $[];

global map<integer,string> CreateProductDirectoryMap(integer base_src)
{
    map<integer,string> ret = $[];
    list<integer> enabled_srcs = Pkg::SourceGetCurrent(true);
    list known_products = [];

    foreach(integer id, enabled_srcs, ``{
	    if (id == base_src)
	    {
		// this is the base source
		ret[id] = "/";
	    }
	    else
	    {
		map productData = Pkg::SourceProductData(id);
		string prod_name = productData["productname"]:"";

		if (prod_name == nil && prod_name == "")
		{
		    prod_name = "add_on";
		}

		string prod_name_base = prod_name;
		integer addon_index = 2;

		while(contains(known_products, prod_name))
		{
		    prod_name = prod_name_base + sformat("_%1", addon_index);
		    addon_index = addon_index + 1;
		}

		known_products = add(known_products, prod_name);
		ret[id] = "Addons/" + prod_name + "/";

		y2milestone("Using directory '%1' for source %2 (%3)", prod_name, id, productData["productname"]:"");
	    }
	}
    );

    y2milestone("Directory mapping: %1", ret);

    return ret;
}


/**
 * Check Product dependencies and determine product to be used for
 * booting. Also determine what is the main product.
 *
 */
global define integer checkProductDependency() ``{

    list<integer> sources = UrlToId(Config["sources"]:[]);

    if (size(sources) == 1)
    {
	y2milestone("Only one source selected");
	return sources[0]:-1;
    }

    // the products must be in the pool
    Pkg::SourceLoad();

    list<map> product_deps = Pkg::ResolvableDependencies("", `product, "");
    y2milestone("found products: %1", product_deps);

    // filter out unused products
    product_deps = filter(map prod, product_deps, {return contains(sources, prod["source"]:-1);});

    y2milestone("used products: %1", product_deps);

    // we have to sort the products according to requires to get the base product
    string tsort_input = "";

    foreach(map prod, product_deps,
	{
	    list<string> provides = [];
	    list<string> requires = [];

	    // collect provides and requires dependencies
	    foreach(map dep, (list<map>)prod["dependencies"]:[],
		{
		    string kind = dep["dep_kind"]:"";
		    // replace ' ' -> '_' (tsort uses space as a separator)
		    string name = String::Replace(dep["name"]:"", " ", "_");

		    if (name != "")
		    {
			if (kind == "provides")
			{
			    provides = add(provides, name);
			}
			else if (kind == "requires")
			{
			    requires = add(requires, name);
			}
		    }
		}
	    );

	    integer src = prod["source"]:-1;

	    y2milestone("Source %1: provides: %2, requires: %3", src, provides, requires);

	    string src_str = sformat("@repository_id:%1@", src);

	    // add requires dependencies to the tsort input
	    foreach(string r, requires,
		{
		    tsort_input = tsort_input + sformat("%1 %2\n", src_str, r);
		}
	    );

	    // add provides dependencies to the tsort input
	    foreach(string p, provides,
		{
		    tsort_input = tsort_input + sformat("%1 %2\n", p, src_str);
		}
	    );
	}
    );

    y2milestone("tsort input: %1", tsort_input);

    // run tsort
    map sorted = (map)SCR::Execute(.target.bash_output, sformat("echo '%1' | tsort | tac", String::Quote(tsort_input)));
    list<string> sorted_prods = splitstring(sorted["stdout"]:"", "\n");
    y2milestone("Sorted products: %1", sorted_prods);

    integer base_source = sources[0]:-1;

    foreach(string line, sorted_prods,
	{
	    string src_id = regexpsub(line, "@repository_id:([0-9]*)@", "\\1");

	    if (src_id != nil)
	    {
		base_source = tointeger(src_id);
		y2milestone("Found base source: %1", base_source);
		break;
	    }
	}
    );

    return base_source;
}

global string CreateAddonFile(map<integer,string> products)
{
    y2milestone("Product map: %1", products);

    string ret = "";

    foreach(integer srcid, string subdir, products,
	{
	    if (subdir != nil && subdir != "" && subdir != "/")
	    {
		if (size(ret) > 0)
		{
		    ret = ret + "\n";
		}

		ret = ret + "relurl://./" + subdir;
	    }
	}
    );

    y2milestone("addon_products content: %1", ret);

    return ret;
}


global list<string> BootFiles(integer srcid)
{
    y2milestone("Downloading boot/directory.yast from src %1...", srcid);
    string local_directory_yast = Pkg::SourceProvideOptionalFile(srcid, 1, "/boot/directory.yast");

    y2milestone("directory.yast from src %1: %2", srcid, local_directory_yast);

    list<string> ret = [];

    if (local_directory_yast != nil)
    {
	string listing = (string)SCR::Read(.target.string, local_directory_yast);

	ret = splitstring(listing, "\n");
	ret = filter(string f, ret, {return f != "";});
    }

    y2milestone("Content of boot/directory.yast: %1", ret);

    return ret;
}


/**
 * Write the modified file with pattern definitions
 * @param file_path path to pattern file
 * @param patterns list of patterns defined in this file
 * @return success
 */
global boolean WritePatternFile (string file_path, list<map> patterns) {

    boolean ret	= true;
    if (pattern_descr == nil)
	pattern_descr	= AddOnCreator::pattern_descr;

    SCR::Execute (.target.remove, file_path);
    boolean gzip = substring (file_path, size (file_path) - 3, 3) == ".gz";
    if (gzip)
	file_path	= substring (file_path, 0, size (file_path) - 3);

    string file		= "";
    foreach (map pattern, patterns, {

	if (file != "")
	{
	    file = sformat ("%1\n# --------------- %2 ----------------\n\n",
		file, pattern["Pat"]:"");
	}
	file	= file	+ sformat ("=Ver: %1\n\n=Pat: %2\n",
	    pattern["Ver"]:"5.0", pattern["Pat"]:"");
	pattern	= remove (remove (pattern, "Ver"), "Pat");
	string last_key	= "";
	foreach (string key, any val, (map<string,any>) pattern, {
	    map descr		= pattern_descr[key]:$[];
	    // substring (key,0,3) is because of Des.lang, Sum.lang and Cat.lang
	    string shortkey	= substring (key,0,3);
	    if (pattern_descr[shortkey]:$[] != $[] &&
		substring (key, 3, 1) == ".")
	    {
		descr		= pattern_descr[shortkey]:$[];
	    }
	    else shortkey	= key;
	    if (val == nil || val == "" || val == [] || descr["internal"]:false)
		return;
	    if (file != "" && last_key != shortkey)
		file	= file + "\n";
	    if (descr["single_line"]:false)
	    {
		file = file + sformat ("=%1: %2\n", key, val);
	    }
	    else
	    {
		file = file + sformat ("+%1:\n%2\n-%1:\n", key, val);
	    }
	    last_key	= shortkey;
	});
    });
    if (file != "")
    {
	map out	= (map) SCR::Execute (.target.bash_output, "LANG=C date");
	file	= file + sformat ("\n\n# Generated by YaST on %1.",
	    deletechars (out["stdout"]:"", "\n"));
	SCR::Write (.target.string, file_path, file);
	if (gzip && gzip_installed ())
	{
	    y2milestone ("compressing pattern file: %1", SCR::Execute (
		.target.bash, sformat ("gzip '%1'", file_path)));
	}
    }
    return ret;
}

global map<string,any> GetBootInfoRepo(integer repo)
{
    list<string> boot_files = ProductCreator::BootFiles(repo);
    boolean bootable_product = size(boot_files) > 0;

    string arch = ProductCreator::GetArch();
    // ppc64 has /boot/ppc
    string boot_architecture = contains(boot_files, arch + "/") ? arch : "";

    // TODO FIXME: add ppc 64 hack
    // if (arch)== "ppc64") ? "ppc" : arch;

    map<string,any> ret = $[ "bootable" : bootable_product, "boot_architecture" : boot_architecture ];

    y2milestone("Bootinfo: %1", ret);

    return ret;
}

global map<string,any> GetBootInfo()
{
    string base_url = Config["base_repo"]:"";

    y2milestone("Configured base repository: %1", base_url);

    // detect the base source
    integer base_source = (base_url != "") ? (UrlToId([base_url])[0]:-1) : checkProductDependency();

    map<string,any> ret = GetBootInfoRepo(base_source);
    ret = add(ret, "base_source", base_source);

    return ret;
}

/**
 * Create Skeleton
 * @return boolean true on success
 */
global define boolean CreateSkeleton(integer base_source, boolean bootable_product, string boot_architecture)
{
    integer ret = 0;
    boolean success = true;
    boolean savespace = Config["savespace"]:false;
    boolean sp = false;
    string sles_path = "";
    integer sles_src = 0;
    string descr_dir = "";
    string arch = GetArch();

    y2milestone("Config: %1", Config);

    // Create skeleton directory
    skel_root = sformat("%1/%2", Config["iso-directory"]:"", Config["name"]:"");
    SCR::Execute(.target.mkdir, skel_root);

    if (bootable_product)
    {
	Exec(sformat("/bin/mkdir -p '%1/boot/%2'", String::Quote(skel_root), String::Quote(boot_architecture)));
    }

    list<integer> enabled = Pkg::SourceGetCurrent(true);
    if (size(enabled) == 0 )
        return false;
    y2milestone("enabled sources: %1", enabled );
    string source = "";
    string descrDir = "";
    string dataDir = "";

    if (bootable_product)
    {
	if (_arch == "i386" || _arch == "x86_64")
	{
	    Exec(sformat("/bin/mkdir -p '%1/boot/%2/loader'", String::Quote(skel_root), String::Quote(boot_architecture)));
	}
	else if (_arch == "ppc" || _arch == "ppc64")
	{
	    // FIXME PS3 is optional
	    Exec(sformat("/bin/mkdir -p '%1/PS3'", String::Quote(skel_root)));
	    Exec(sformat("/bin/mkdir -p '%1/ppc'", String::Quote(skel_root)));
	    Exec(sformat("/bin/mkdir -p '%1/suseboot'", String::Quote(skel_root)));
	}
    }

    product_map = CreateProductDirectoryMap(base_source);

    // create directories for the addons
    foreach(integer srcid, string dir, product_map, {
	    if (dir != "/")
	    {
		Exec(sformat("/bin/mkdir -p '%1/%2'", String::Quote(skel_root), String::Quote(dir)));
	    }
	}
    );

    string main_skel_root = skel_root;

    foreach(integer id, enabled, ``{
	map general_info = Pkg::SourceGeneralData(id);

	// no extra data for YUM sources
	if (general_info["type"]:"" == "YUM")
	{
	    return false;
	}

	map this_source = meta[id]:$[];
	source   = this_source["path"]:"";
	meta_local = ReadContentFile(id);

	skel_root = main_skel_root + "/" + product_map[id]:"";
	y2milestone("Using directory %1 for source %2", skel_root, id);

	if (source == "")
	    return false;

	// copy /docu (release notes) when present
	CopyDocu(id, skel_root);

	y2milestone("source: %1", source);
	descr_dir = this_source["productData","descrdir"]:"suse/setup/descr";

	y2debug("content: %1", meta_local);
	if (this_source["productData","baseproductname"]:"" != "" &&
	    issubstring(meta_local["FLAGS"]:"", "SP"))
	{
	    y2milestone("Service pack detected");
	    y2debug("this source: %1", this_source );
	    descrDir = this_source["productData","descrdir"]:"suse/setup/descr";
	    dataDir  = this_source["productData", "datadir"]:"suse";
	    y2debug("source data: %1", this_source["sourceData", "url"]:"" );
	     // Service Pack
	    if (bootable_product)
	    {
		if (savespace)
		{
		    // Installation, rescue images
		    CopyFile(id, 1, sformat("boot/%1/rescue", boot_architecture),
			sformat("%1/boot/%2", skel_root, boot_architecture));

		    // Loader, x86 specific
		    if (_arch == "i386" || _arch == "x86_64")
		    {
			// recursive copy of /boot/$arch/loader/*
			CopyDirectoryRec(id, 1, sformat("boot/%1/loader", boot_architecture), sformat("%1/boot/%2", skel_root, boot_architecture));

			// nonrecursive copy of /boot/$arch/*
			CopyDirectoryNonRec(id, 1, sformat("boot/%1", boot_architecture), sformat("%1/boot", skel_root));
		    }
		    else if (_arch == "ppc" || _arch == "ppc64")
		    {
			// recursive copy of /boot
			CopyDirectoryRec(id, 1, "boot", skel_root);
			CopyPPCBoot(id, skel_root);
		    } else
		    {
			CopyDirectoryRec(id, 1, "boot", skel_root);
		    }
		}
		else
		{
		    CopyDirectoryRec(id, 1, "boot", skel_root);

		    if (_arch == "ppc" || _arch == "ppc64")
		    {
			CopyPPCBoot(id, skel_root);
		    }
		}

		// copy the driver update
		CopyOptionalFile(id, 1, "driverupdate", skel_root);
	    }

	    // copy the descr directory
	    Exec(sformat("/bin/mkdir -p '%1/%2'", String::Quote(skel_root), String::Quote(descrDir)));
	    CopyDirectoryRec(id, 1, descrDir, sformat("%1/%2", skel_root, UpDir(descrDir)));

	    sp = true;
	}
	else if  (this_source["productData","baseproductname"]:"" != "" )
	{
	    // SLES
	    y2milestone("SLES source detected");

	    sles_path = source;
	    sles_src = id;
	    y2milestone("this source: %1", this_source );
	    descrDir = this_source["productData","descrdir"]:"suse/setup/descr";
	    dataDir  = this_source["productData", "datadir"]:"suse";
	    y2debug("source data: %1", this_source["sourceData", "url"]:"" );
	    success = (boolean)SCR::Execute(.target.mkdir, sformat("'%1/%2'", String::Quote(skel_root), String::Quote(dataDir)));
	    if (!success)
	    {
		y2error("Cannot create directory: %1", sformat("'%1/%2'", String::Quote(skel_root), String::Quote(dataDir)));
		return false;
	    }
	 
	    Exec(sformat("/bin/mkdir -p '%1/%2'", String::Quote(skel_root), String::Quote(descrDir)));	    

	    if (savespace)
	    {
		if (bootable_product)
		{
		    CopyFile(id, 1, sformat("boot/%1/rescue", boot_architecture), sformat("%1/boot/%2", skel_root, boot_architecture));
		    CopyFile(id, 1, sformat("boot/%1/root", boot_architecture), sformat("%1/boot/%2", skel_root, boot_architecture));
		    CopyOptionalFile(id, 1, sformat("boot/%1/root.fonts", boot_architecture), sformat("%1/boot/%2", skel_root, boot_architecture));
		}

		// copy content* files
		CopyFilesRegExp(id, 1, "/", skel_root, "^content");

		CopyFile(id, 1, "control.xml", skel_root);
	    }
	    else
	    {
		if (bootable_product)
		{
		    CopyFile(id, 1, sformat("boot/%1/root", boot_architecture), sformat("%1/boot/%2", skel_root, boot_architecture));
		    CopyOptionalFile(id, 1, sformat("boot/%1/root.fonts", boot_architecture), sformat("%1/boot/%2", skel_root, boot_architecture));
		}

		// copy base files, skip all directories
		CopyDirectoryNonRec(id, 1, "/", skel_root);
	    }

	    y2milestone("source: %1, descrDir: %2, skel_root: %3", source, descrDir, skel_root);
	    // Descriptions, Selections and package databases
	    CopyDirectoryRec(id, 1, descrDir, sformat("%1/%2", skel_root, UpDir(descrDir)));

	    // Prepare media files
	    CopyDirectoryRec(id, 1, "media.1", skel_root);
	    Exec(sformat("/usr/bin/head -n 2 %1/media.1/media  >   %1/media.1/media.tmp && mv %1/media.1/media.tmp %1/media.1/media",  String::Quote(skel_root)));
	}
	else
	{
	    // copy base files, skip all directories
	    CopyDirectoryNonRec(id, 1, "/", skel_root);
	}
    });

    // set the root directory back
    skel_root = main_skel_root;

    if (!sp)
    {
	y2milestone("NOT SP");


	if (sles_path != "")
	{
	    source = sles_path;
	    base_source = sles_src;
	}

	if (descrDir == "")
	{
	    descrDir = descr_dir;
	}

	if (dataDir == "")
	{
	    dataDir = String::FirstChunk(descr_dir, "/");

	    if (dataDir == "")
	    {
		dataDir = "suse";
	    }
	}

	if (bootable_product)
	{
	    if (savespace)
	    {
		CopyFile(base_source, 1, sformat("boot/%1/rescue", boot_architecture), sformat("%1/boot/%2", skel_root, boot_architecture));
		CopyFile(base_source, 1, sformat("boot/%1/root", boot_architecture), sformat("%1/boot/%2", skel_root, boot_architecture));
		CopyOptionalFile (base_source, 1, sformat("boot/%1/root.fonts", boot_architecture), sformat("%1/boot/%2", skel_root, boot_architecture));
		// Loader, x86 specific
		if (_arch == "i386" || _arch == "x86_64")
		{
		    // recursive copy of /boot/$boot_architecture/loader/*
		    CopyDirectoryRec(base_source, 1, sformat("boot/%1/loader", boot_architecture), sformat("%1/boot/%2", skel_root, boot_architecture));

		    // nonrecursive copy of /boot/$boot_architecture/*
		    CopyDirectoryNonRec(base_source, 1, sformat("boot/%1", boot_architecture), sformat("%1/boot", skel_root));
		}
		else if (_arch == "ppc" || _arch == "ppc64")
		{
		    CopyPPCBoot(base_source, skel_root);

		    // recursive copy of /boot
		    CopyDirectoryRec(base_source, 1, "boot", skel_root);
		}
		else
		{
		    // recursive copy of /boot/loader/*
		    CopyDirectoryRec(base_source, 1, "boot", skel_root);
		}
	    }
	    else
	    {
		CopyDirectoryRec(base_source, 1, "boot", skel_root);

		if (_arch == "ppc" || _arch == "ppc64")
		{
		    CopyPPCBoot(base_source, skel_root);
		}
	    }
	}
    }

  foreach(integer source_id, enabled, ``{
    map general_info = Pkg::SourceGeneralData(source_id);

    // no extra action for YUM sources
    if (general_info["type"]:"" == "YUM")
    {
	return;
    }

    map this_source = meta[source_id]:$[];
    source   = this_source["path"]:"";
    meta_local = ReadContentFile(source_id);

    skel_root = main_skel_root + "/" + product_map[source_id]:"";
    y2milestone("Using directory %1 for source %2", skel_root, source_id);

    // copy descriptions
    string descrdir = meta[source_id, "productData","descrdir"]:"suse/setup/descr";
    Exec(sformat("/bin/mkdir -p '%1/%2'", String::Quote(skel_root), String::Quote(descrdir)));
    CopyDirectoryRec(source_id, 1, descrdir, sformat("%1/%2", skel_root, UpDir(descrdir)));

    string datadir  = meta[source_id, "productData", "datadir"]:"suse";
    string slidedir = datadir + "/setup/slide/";

    if (!savespace)
    {
	y2milestone("slidedir: %1", slidedir);

	// check whether the slideshow directory is present
	string l_dirlist = Pkg::SourceProvideOptionalFile(source_id, 1, slidedir + "directory.yast");
	if (l_dirlist != nil)
	{
	    string l_slidedir = Pkg::SourceProvideDirectory(source_id, 1, slidedir, true, true);

	    if (l_slidedir != nil && l_slidedir != "")
	    {
		// copy slide show
		Exec(sformat("/bin/mkdir -p '%1/%2'", String::Quote(skel_root), String::Quote(slidedir)));
		Exec(sformat("/bin/cp -a -- '%1' '%2/%3'", String::Quote(l_slidedir), String::Quote(skel_root), String::Quote(datadir + "/setup/")));
	    }
	}
	else
	{
	    y2milestone("Slideshow is missing");
	    if (bootable_product)
	    {
		Exec(sformat("/bin/mkdir -p '%1/%2'", String::Quote(skel_root), String::Quote(slidedir)));
		Exec(sformat("> '%1/%2/directory.yast'", String::Quote(skel_root), String::Quote(slidedir)));
	    }
	}
    }
    else
    {
	y2milestone("Save space - do not copy the slideshow");
	Exec(sformat("/bin/mkdir -p '%1/%2'", String::Quote(skel_root), String::Quote(slidedir)));
	Exec(sformat("> '%1/%2/directory.yast'", String::Quote(skel_root), String::Quote(slidedir)));
    }

    y2milestone("source: %1, descrDir: %2, skel_root: %3", source, descrDir, skel_root);


    // copy media.1 directory
    CopyDirectoryRec(source_id, 1, "media.1", skel_root);
    Exec(sformat("/usr/bin/head -n 2 '%1/media.1/media'  >   '%1/media.1/media.tmp' && mv '%1/media.1/media.tmp' '%1/media.1/media'", String::Quote(skel_root)));

    // create a copy of the autoyast profile (the new profile accepts even unsigned source)
    string autoyast_copy = "";

    // the copy is not needed if the sourse will be signed with a gpg key
    if (Config["profile"]:""!="" && Config["gpg_key"]:"" != "")
    {
	string prof = Config["profile"]:"";

	if (!Profile::ReadXML(prof))
	{
	    Report::Error(_("Error reading control file."));
	}
	else
	{
	    y2milestone("Current profile: %1", Profile::current);

	    if ( Profile::current["general", "signature-handling" ]:nil == nil)
	    {
		Profile::current["general", "signature-handling" ] = $[];
	    }

	    Profile::current["general", "signature-handling", "accept_unsigned_file"] = true;

	    // add prefix to the name
	    list<string> parts = splitstring(prof, "/");
	    parts[size(parts) - 1] = "install_"+ parts[size(parts) - 1]:"";
	    prof = mergestring(parts, "/");

	    boolean saved = Profile::Save(prof);
	    y2milestone("Modified profile saved to %1: %2", prof, saved);

	    if (saved)
	    {
		autoyast_copy = prof;
	    }
	    else
	    {
		// saving to the original location has failed, save copy to tmpdir
		string tmpdir = (string)SCR::Read(.target.tmpdir);
		prof = tmpdir + "/product-creator-autoyast_profile.xml";

		// save the copy
		saved = Profile::Save(prof);

		y2milestone("Copy of the profile saved to %1: %2", prof, saved);
		if (saved)
		{
		    autoyast_copy = prof;
		}
	    }
	}
    }

    // copy autoyast profile
    if (Config["profile"]:""!="" && Config["copy_profile"]:false)
    {
	if (autoyast_copy != "")
	{
	    // save the original file and the copy
	    Exec(sformat("/bin/cp -- '%1' '%2/autoinst.xml'", String::Quote(autoyast_copy), String::Quote(skel_root)));
	    Exec(sformat("/bin/cp -- '%1' '%2/autoinst.orig.xml'", String::Quote(Config["profile"]:""), String::Quote(skel_root)));
	}
	else
	{
	    // save the original file (a copy is not available)
	    Exec(sformat("/bin/cp '%1' '%2/autoinst.xml'", String::Quote(Config["profile"]:""), String::Quote(skel_root)));
	}
    }

    // Media nr.
    integer count = 1;

    Exec(sformat("/bin/echo %1 >> '%2/media.1/media'", count, String::Quote(skel_root)));

    // make the source digitally unsigned (because signed descr/packages file has been modified)
    if (boot_architecture != "")
    {
	// remove the key and the checksum
	Exec(sformat("/bin/rm '%1/content.asc' '%1/content.key'", String::Quote(skel_root)));
	// remove the meta information from content file
	Exec(sformat("/usr/bin/grep -v -e '^KEY ' -e '^META ' '%1/content' > '%1/content.new'", String::Quote(skel_root)));
	Exec(sformat("/bin/mv '%1/content.new' '%1/content'", String::Quote(skel_root)));
	// mark the final product as 'base'
	if (SCR::Execute (.target.bash, sformat("/usr/bin/grep '^TYPE' '%1/content'", String::Quote(skel_root))) != 0)
	    Exec(sformat("echo 'TYPE base' >> '%1/content'", String::Quote(skel_root)));

	// recreate the index file
// FIXME: use create_directory when it supports parameter with spaces
//	Exec(sformat("/bin/rm -f '%1/directory.yast' && /usr/bin/create_directory.yast '%1'", String::Quote(skel_root)));
	Exec(sformat("/bin/rm -f '%1/directory.yast'; cd '%1'; ls | grep -v -e '^\\.$' -e '^\\.\\.$' > '%1/directory.yast'", String::Quote(skel_root)));
    }

    // remove unused patterns (they cannot be used due to missing packages)
    if (Config["type"]:`unknown == `patterns)
    {

        list<string> used_patterns = Config["addons"]:[];
        if (Config["base"]:"" != "")
	{
	    used_patterns = prepend(used_patterns, Config["base"]:"");
        }
	y2milestone("used patterns: %1", used_patterns);


	// addons 'doesn't include patterns added via dependency
	// better find the pattern dependencies with solver
	foreach(string p, used_patterns, {
	    Pkg::ResolvableInstall (p, `pattern);
	});
	Pkg::PkgSolve (true);
	foreach (map pat, Pkg::ResolvableProperties ("", `pattern, ""),
	{
	    if (pat["status"]:`none == `selected)
	    {
		used_patterns   = add (used_patterns, pat["name"]:"");
		y2milestone ("selected pattern: %1", pat);
	    }
	});

	y2milestone("patterns + dependencies: %1", used_patterns);

	list<string> files = (list<string>)SCR::Read(.target.dir, sformat("%1/%2", skel_root, descrDir));
	if (files == nil)
	{
	    files = [];
	}

	files = filter(string f, files, {return regexpmatch(f, "\\.pat$") || regexpmatch(f, "\\.pat.gz$");});

	y2milestone("found pattern files: %1", files);

	boolean refresh_diryast = false;

	foreach (string file, files, {
	    string file_path = sformat ("%1/%2/%3", skel_root, descrDir, file);
	    list<map> pts = (list<map>) SCR::Read (.pattern.list, file_path);
	    boolean pattern_modified	= false;
	    pts	= filter (map pt, pts, {
		string pattern	= splitstring (pt["Pat"]:"", " \t")[0]:"";
		if (! contains (used_patterns, pattern) &&
		    pt["Vis"]:true != false) // do not remove invisible patterns
		{
		    y2debug ("pattern to delete: %1", pattern);
		    pattern_modified	= true;
		    return false;
		}
		y2milestone ("pattern %1 will stay", pattern);
		return true;
	    });
	    if (pattern_modified)
	    {
		success	= success && WritePatternFile (file_path, pts);
		refresh_diryast	= true;
	    }
	});

	y2milestone("removed patterns: %1", success);

	if (refresh_diryast)
	{
	    // regenerate directory.yast and patterns file
	    // FIXME: string cmd = sformat("/bin/rm -f -- '%1/%2/directory.yast' && /usr/bin/create_directory.yast '%1/%2'", String::Quote(skel_root), String::Quote(descrDir));
	    string cmd = sformat("/bin/rm -f '%1/%2/directory.yast'; cd '%1/%2'; ls | grep -v -e '^\\.$' -e '^\\.\\.$' > '%1/%2/directory.yast'", String::Quote(skel_root), String::Quote(descrDir));
	    success = success && Exec(cmd);
	    y2milestone ("success: %1", success);

	    // this will print error message since they are either pat or pat.gz
	    cmd =  sformat("cd '%1/%2'; ls *.pat *.pat.gz > '%1/%2/patterns'", String::Quote(skel_root), String::Quote(descrDir));
	    Exec(cmd);
	}
    }
    // update MD5SUMS file
    success = success && UpdateMD5File(sformat("%1/%2", skel_root, descrDir));
    y2debug("success: %1", success);
  });

    skel_root = main_skel_root;

    string addon_file = CreateAddonFile(product_map);
    if (size(addon_file) > 0)
    {
	string target_addon_file = main_skel_root + "/add_on_products";
	y2milestone("Writing addon products to %1", target_addon_file);
	success = success && SCR::Write(.target.string, target_addon_file, addon_file);
    }

    y2milestone("Created skeleton: %1", success);
    return success;
}

/**
 * see http://en.opensuse.org/Secure_Installation_Sources
 * @param gpg_key GPG key ID or empty if the product should be unsigned
 * @param initrd_file path to the initrd file
 * @return boolean true on success
 */
boolean InsertKeyToInitrd(string gpg_key, string initrd_file)
{
    if (gpg_key == "")
    {
	y2milestone("Disabling signature checks in initrd %1", initrd_file);
    }
    else
    {
	y2milestone("Adding GPG key %1 to initrd %2", gpg_key, initrd_file);
    }

    // initrd is a cpio.gz archive

    list<string> parts = splitstring(initrd_file, "/");
    if (size(parts) > 1)
    {
	// remove the last element
	parts = remove(parts, size(parts) - 1);
    }
    string base = mergestring(parts, "/");

    // uncompress the initrd
    y2milestone("Uncompressing initrd: %1", initrd_file);
    boolean ret = Exec(sformat("cd '%1' && gunzip < '%2' > '%2.cpio'", String::Quote(base), String::Quote(initrd_file)));
    if (!ret) return false;

    string new_file = "";

    if (gpg_key == "")
    {
	// remove the old file before unpacking
	ret = Exec(sformat("rm -rf '%1/linuxrc.config'", String::Quote(base)));

	// unpack 'linuxrc.config' file
	ret = Exec(sformat("cd '%1' && cpio -i -H newc -F '%2.cpio' linuxrc.config",
	    String::Quote(base), String::Quote(initrd_file)));
	if (!ret) return false;

	// add 'Insecure: 1' option
	ret = Exec(sformat("cd '%1' && echo 'Insecure:\t1' >> linuxrc.config", String::Quote(base)));
	if (!ret) return false;
	y2milestone("Updated linuxrc.config: %1", SCR::Read(.target.string, base + "/linuxrc.config"));

	// add linuxrc instead of a gpg key
	new_file = "linuxrc.config";
    }
    else
    {
	ret = GPG::ExportPublicKey(gpg_key, sformat("%1/gpg-%2.gpg", base, gpg_key));
	if (!ret) return false;

	// add the exported GPG key
	new_file = sformat("gpg-%1.gpg", gpg_key);
    }

    // uncompress the archive and add the GPG key or new linuxrc.config file
    string command = sformat("cd '%1' && echo '%3' | cpio -o -H newc -A -F '%2.cpio'",
	String::Quote(base), String::Quote(initrd_file), String::Quote(new_file));
    ret = Exec(command);
    if (!ret) return false;

    if (new_file != "linuxrc.config")
    {
	// extract installkey.gpg from cpio archive
	command = sformat ("cd '%1'; cpio -i -H newc -F '%2.cpio' installkey.gpg",
	    String::Quote(base), String::Quote(initrd_file));

	ret = Exec(command);
	if (!ret) return false;

	// add our new key to installkey.gpg keyring
	command = sformat ("cd '%1'; gpg --no-default-keyring --keyring ./installkey.gpg --import '%2'",
	    String::Quote(base), String::Quote(new_file));
	ret = Exec(command);
	if (!ret) return false;

	// place new installkey.gpg back to the archive
	command = sformat ("cd '%1' && echo installkey.gpg | cpio -o -H newc -A -F '%2.cpio'",
	    String::Quote(base), String::Quote(initrd_file));

	ret = Exec(command);
	if (!ret) return false;
    }

    // compress the archive, remove the temporary files
    command = sformat("gzip --best < '%1.cpio' > '%1' && rm -f '%1.cpio' '%2'",
	String::Quote(initrd_file), String::Quote(new_file));
    ret = Exec(command);

    return ret;
}

string DumpKernelFromObjectFile(string object)
{
    y2milestone("Extracting kernel from file %1", object);
    string tmpdir = (string)SCR::Read(.target.tmpdir);
    string target = tmpdir + "/tmp_kernel.gz";

    string command = sformat("objcopy -O binary -j .kernel:vmlinux.strip '%1' '%2'", String::Quote(object), String::Quote(target));
    string ret = (Exec(command)) ? target : "";

    y2milestone("Kernel extracted to %1", ret);

    return ret;
}

string GunzipKernel(string kernel_gz)
{
    string command = sformat("gunzip -f %1", kernel_gz);
    boolean success = Exec(command);
    string ret = "";

    // remove .gz suffix from the file name
    if (success)
    {
	ret = regexpsub (kernel_gz, "^(.*)\\.gz$", "\\1");
    }

    y2milestone("Kernel unpacked to %1", ret);

    return ret;
}

string CreateMkzimageCommand()
{
    string ret = "";

    if ((ProductCreator::Config["arch"]:"" == "ppc"
	|| ProductCreator::Config["arch"]:"" == "ppc64")
	&& !Arch::ppc())
    {
	// find the lilo package
	list<map> ppc_lilo = Pkg::ResolvableProperties("lilo", `package, "");
	y2milestone("found lilo packages: %1", ppc_lilo);

	map lilo_pkg = ppc_lilo[0]:$[];

	y2milestone("selected lilo package: %1", lilo_pkg);

	if (lilo_pkg == nil || lilo_pkg == $[])
	{
	    y2error("lilo package was not found");
	    return "";
	}

	// download the package
	string downloaded_pkg = Pkg::SourceProvideFile(lilo_pkg["source"]:-1, lilo_pkg["medium_nr"]:-1, lilo_pkg["path"]:"lilo");

	y2milestone("Downloaded lilo package: %1", downloaded_pkg);

	if (downloaded_pkg == nil || downloaded_pkg == "")
	{
	    y2error("Downloading package lilo failed");
	    return "";
	}

	// create a tmpdir
	string tmp_dir = (string)SCR::Read(.target.tmpdir);
	string tmp_lilo = tmp_dir + "/lilo-" + lilo_pkg["version"]:"";

	// remove the directory if it already exists (e.g. from the previous run)
	Exec("rm -rf " + tmp_lilo);

	SCR::Execute(.target.mkdir, tmp_lilo);

	// unpack the package into the tmpdir
	string unpack_cmd = sformat("cd '%1' && /usr/bin/rpm2cpio '%2' | /usr/bin/cpio -i --make-directories", String::Quote(tmp_lilo), String::Quote(downloaded_pkg));

	if (!Exec(unpack_cmd))
	{
	    y2error("Unpacking lilo package failed");
	    return "";
	}

	// use the linker from cross-ppc-binutils,
	// set --objdir option to the unpacked PPC lilo package
	ret = "PATH=/opt/cross/powerpc-linux/bin:$PATH '" + String::Quote(tmp_lilo) + "/bin/mkzimage' --objdir '"
	    + String::Quote(tmp_lilo) + "/lib/lilo' --board chrp --vmlinux '%1' --initrd '%2' --output '%3/new_inst' --tmp '%3'";
    }
    else
    {
	ret = "/bin/mkzimage --board pmac --vmlinux '%1' --initrd '%2' --output '%3/new_inst' --tmp '%3'";
    }

    y2milestone("mkzimage command template: %1", ret);
    return ret;
}

global boolean InsertKeyToInitrds(string gpg_key, string base_dir)
{
    // get initrd list
    string command = "";
    map out = $[];
    string find_output = "";

    if (SCR::Read(.target.size, base_dir + "/boot") >= 0)
    {
	y2milestone("Searching for 'initrd' in %1/boot...", base_dir);
	command = sformat("cd '%1' && find boot -type f -name 'initrd'", String::Quote(base_dir));
	out = (map)SCR::Execute(.target.bash_output, command);
	find_output = out["stdout"]:"";
    }

    map<string,string> inst_mapping = $[];

    if (SCR::Read(.target.size, base_dir + "/suseboot") >= 0)
    {
	y2milestone("Searching for 'initrd*' in %1/suseboot...", base_dir);
	command = sformat("cd '%1' && find suseboot -type f -name 'initrd*'", String::Quote(base_dir));
	out = (map)SCR::Execute(.target.bash_output, command);
	find_output = find_output + out["stdout"]:"";

	if (size(out["stdout"]:"") == 0)
	{
	    y2milestone("initrd not found, searching for inst*");

	    command = sformat("cd '%1' && find suseboot -type f -name 'inst32'; find suseboot -type f -name 'inst64'", String::Quote(base_dir));
	    out = (map)SCR::Execute(.target.bash_output, command);

	    list<string> inst_files = splitstring(out["stdout"]:"", "\n");
	    // remove empty strings
	    inst_files = filter(string inst, inst_files, {return inst != "";});

	    if (size(inst_files) > 0)
	    {
		y2milestone("Found inst* files: %1", inst_files);

		integer index = 0;
		// unpack the initrd from the inst* object
		foreach(string inst, inst_files,
		    {
			string tmp_initrd = sformat("suseboot/.tmp_yast_initrd%1.gz", index);

			command = sformat("cd '%1' && objcopy -O binary -j .kernel:initrd '%2' '%3'", String::Quote(base_dir), String::Quote(inst), tmp_initrd);

			out = (map)SCR::Execute(.target.bash_output, command);

			if (out["exit"]:-1 == 0)
			{
			    y2milestone("Extracted %1 from %2", tmp_initrd, inst);
			    find_output = find_output + tmp_initrd + "\n";

			    inst_mapping = add(inst_mapping, inst, tmp_initrd);
			}

			index = index + 1;
		    }
		);

	    }
	}
    }
    string arch	= GetArch ();
    list<string> initrds = splitstring(find_output, "\n");
    // remove empty strings
    initrds = filter (string initrd, initrds, {
	if (initrd == "")
	    return false;
	// workaround for bnc#498464
	if (arch == "s390x" && issubstring (initrd, "boot/i386/"))
	    return false;
	return true;
    });
    y2milestone("Found initrds: %1", initrds);

    boolean ret = true;
    foreach(string initrd, initrds,
	{
	    boolean inserted = InsertKeyToInitrd(gpg_key, base_dir + "/" + initrd);

	    if (!inserted)
	    {
		Report::Error(sformat(_("Could not add GPG key %1 to initrd
%2.
"), gpg_key, initrd));
		ret = false;
	    }
	}
    );

    if (size(inst_mapping) > 0)
    {
	// create the template command if needed (download the needed lilo package just once)
	string mkzimage_template = CreateMkzimageCommand();

	if (mkzimage_template != "")
	{
	    // put the initrd back to the inst file
	    foreach(string orig_inst, string tmp_initrd, inst_mapping,
		{
		    y2milestone("%1 -> %2", tmp_initrd, orig_inst);

		    if (orig_inst == "suseboot/inst32" || orig_inst == "suseboot/inst64")
		    {
			// extract kernel
			string gzkernel = DumpKernelFromObjectFile(base_dir + "/" + orig_inst);

			if (gzkernel != "")
			{
			    // unpack the kernel image - required by mkzimage
			    string kernel = GunzipKernel(gzkernel);
			    string tmp_dir = (string)SCR::Read( .target.tmpdir );

			    string initrd_copy = sformat("%1/tmp_initrd", tmp_dir);

			    // copy the initrd to a temp dir - mkzimage doesn't work properly
			    // when there is a space in path
			    ret = ret && Exec(sformat("mv '%1/%2' '%3'", String::Quote(base_dir), tmp_initrd, initrd_copy));

			    // create new inst file
			    // see mk_ppc_installation-images_bootbinaries.sh (installation-images)
			    command = sformat(mkzimage_template, kernel, initrd_copy, tmp_dir);
			    ret = ret && Exec(command);

			    // remove the temporary files
			    command = sformat("rm -f '%1' '%2'", kernel, initrd_copy);
			    ret = ret && Exec(command);

			    // move the new file to the target directory
			    command = sformat("mv '%1/new_inst' '%2/%3'", tmp_dir, String::Quote(base_dir), orig_inst);
			    ret = ret && Exec(command);
			}
		    }
		    else
		    {
			y2warning("Unsupported inst file: %1", orig_inst);
		    }
		}
	    );
	}
	else
	{
	    y2error("mkzimage command missing, not modifying initrd (%1)", inst_mapping);
	}
    }

    return ret;
}

global boolean SignSUSEtagsSource(string gpg_key, string dir, string passphrase)
{
    // export the key
    boolean success = ExportPublicKey(gpg_key, dir);
    // update SHA1 sums
    success = success && UpdateContentFile(dir, "suse/setup/descr");

    if (!success)
    {
	return false;
    }

    // sign the source
    success = SignSourceFiles(gpg_key, dir, passphrase);

    if (success)
    {
	// update directory.yast file
	// FIXME string command = sformat("/bin/rm -f '%1/directory.yast' && /usr/bin/create_directory.yast '%1'", String::Quote(dir));
	y2milestone("Updating directory.yast ...");
	success = success && Exec(sformat("/bin/rm -f '%1/directory.yast'; cd '%1'; ls | grep -v -e '^\\.$' -e '^\\.\\.$' > '%1/directory.yast'", String::Quote(dir)));
	success = success && Exec(sformat("/bin/rm -f '%1/directory.yast'; cd '%1'; ls | grep -v -e '^\\.$' -e '^\\.\\.$' > '%1/directory.yast'", String::Quote(dir + "/media.1")));
    }

    return success;
}

global boolean SignYUMSource(string gpg_key, string dir, string passphrase)
{
    boolean ret = GPG::SignAsciiDetached(gpg_key, dir + "/repodata/repomd.xml", passphrase);
    ret = ret && GPG::ExportAsciiPublicKey(gpg_key, dir + "/repodata/repomd.xml.key");

    return ret;
}

// do not sign the sources, just update content files
global boolean UpdateContentFiles()
{
    boolean success = true;

    foreach(integer srcid, string dir, product_map,
	{
	    map general_info = Pkg::SourceGeneralData(srcid);

	    if (general_info["type"]:"" == "YaST")
	    {
		success = UpdateContentFile(skel_root + "/" + dir, "suse/setup/descr") && success;
		y2milestone("Updated content file in %1: %2", skel_root + "/" + dir, success);
	    }
	}
    );

    return success;
}

global boolean SignSourceStep()
{
    boolean success = true;

    // sign the files
    string gpg_key = Config["gpg_key"]:"";

    if (gpg_key != "")
    {
	string passphrase = (Mode::commandline()) ? gpg_passphrase : GPGWidgets::AskPassphrasePopup(gpg_key);

	// not aborted
	if (passphrase != nil)
	{
	    // sign each product
	    foreach(integer srcid, string dir, product_map, {
		    boolean signed = false;
		    map general_info = Pkg::SourceGeneralData(srcid);

		    while (!signed)
		    {
			if (general_info["type"]:"" == "YaST")
			{
			    // sign the source
			    signed = SignSUSEtagsSource(gpg_key, skel_root + "/" + dir, passphrase);
			}
			else
			{
			    // sign the source
			    signed = SignYUMSource(gpg_key, skel_root + "/" + dir, passphrase);
			}

			// yes/no popup: error message
			if (!signed)
			{
			    if (Popup::YesNo(_("Error: Could not digitally sign the source.
Try again?
")))
			    {
				passphrase = (Mode::commandline()) ? gpg_passphrase : GPGWidgets::AskPassphrasePopup(gpg_key);
			    }
			    else
			    {
				break;
			    }
			}
		    }

		    success = success && signed;
		}
	    );
	}
	else
	{
	    success = false;
	}

	// insert the key into the installation initrd
	success = success && InsertKeyToInitrds(gpg_key, skel_root);
    }
    else
    {
	// add 'Insecure: 1' to linuxrc.config
	success = success && InsertKeyToInitrds("", skel_root);

	// update content files if the source is not signed (bnc #368146)
	success = success && UpdateContentFiles();
    }

    y2milestone("Source signed: %1", success);
    return success;
}


/**
 * CopyMiscFiles
 * Copy other files to directory tree
 * @return boolean true on success
 */
global define boolean CopyMiscFiles(string boot_arch)
{
    string cpCmd = "";

    string arch = GetArch();
    if (arch == "s390_64") arch = "s390x";

    y2debug("isolinux.cfg: %1", Config["bootconfig"]:"" );

    if (Config["bootconfig"]:"" != "")
    {
        y2debug("custom config available");

	string fname = sformat("%1/boot/%2/loader/isolinux.cfg", skel_root, boot_arch);
	y2milestone("Writing isolinux.cfg to %1", fname);

        SCR::Write(.target.string, fname, Config["bootconfig"]:"" );
    }

    cpCmd = sformat("cp -- '%1/product-creator/message' '%2/boot/%3/loader'",
	String::Quote(Directory::datadir), String::Quote(skel_root), boot_arch);

    Exec(cpCmd);

    cpCmd = sformat("cp -- '%1/product-creator/options.msg' '%2/boot/%3/loader'",
	String::Quote(Directory::datadir), String::Quote(skel_root), boot_arch);

    Exec(cpCmd);

    return true;
}

global boolean CheckUnavailableSources()
{
    list<integer> selected_items = UrlToId(Config["sources"]:[]);

    // remove not found sources (with id = -1)
    selected_items = filter(integer source_id, selected_items, {return source_id >= 0;});

    // were all sources found?
    if (size(Config["sources"]:[]) != size(selected_items))
    {
	list<string> not_found_sources = [];

	// get list of missing sources
	foreach(string selected_url, ProductCreator::Config["sources"]:[],
	    {
		list<integer> url_id = ProductCreator::UrlToId([selected_url]);

		if (url_id[0]:nil == -1)
		{
		    not_found_sources = add(not_found_sources, selected_url);
		}
	    }
	);

	// error message, %1 is list of URLs (one URL per line)
	Report::LongError(sformat(_("These sources were not found:\n%1"), mergestring(not_found_sources, "\n")));
	return false;
    }

    return true;
}

/**
 * Enable source and get source meta data
 * @return true on success
 */
global define boolean EnableSource() ``{
    y2milestone("Config: %1", Config);
    enableSources();

    list<integer> sources = UrlToId(ProductCreator::Config["sources"]:[]);

    list ids = Pkg::SourceStartCache(true);

    if (size(ids) == 0 )
	return false;

    foreach(integer i , sources, ``{
	map<string, any> m = $[];
	m["productData"] = Pkg::SourceProductData(i);
	m["mediaData"] = Pkg::SourceMediaData(i);
	m["sourceData"]	= Pkg::SourceGeneralData(i);
        string p = m["sourceData", "url"]:"";
        map parsed = URL::Parse(p);
        m["path"] = parsed["path"]:"";
	meta[i] = m;
    });

    y2milestone("meta: %1", meta);
    return true;
}


/**
 * Get all possible sources
 * @return available enabled sources list for widget
 */
global define list<term> GetDirSources(string source) ``{
    list<integer> ids = Pkg::SourceStartCache(true);
    list<term> sources = [];
    foreach(integer i , ids, ``{
        map prod = Pkg::SourceProductData(i);
        map media = Pkg::SourceMediaData(i);
	map url = URL::Parse(media["url"]:"");
	if (url["scheme"]:"" == "dir")
	{
	    boolean selected = (source == url["path"]:"");
	    sources = add(sources, `item(`id(url["path"]:""), url["path"]:"", selected));

	}
    });

    return sources;
}


global define void enableSources()``{

    // used by standalone kiwi UI, which does onw sources handling...
    if (!enable_sources)
	return;

    // TODO FIXME: use better way to reset the source config in the package manager
    if (original_config != nil)
    {
	y2milestone("Restoring original config: %1", original_config);
	Pkg::SourceEditSet(original_config);
	Pkg::SourceFinishAll();
    }
    else
    {
	original_config = Pkg::SourceEditGet();
	y2milestone("Current source configuration: %1", original_config);
    }

    Pkg::SourceStartManager(false);

    y2milestone("sources: %1", ProductCreator::Config["sources"]:[]);
    list<integer> sources = UrlToId(ProductCreator::Config["sources"]:[]);
    y2milestone("source IDs: %1", sources);

    foreach(integer id , Pkg::SourceGetCurrent(true), ``{
		y2milestone("Disabling source %1", id);
                Pkg::SourceSetEnabled (id, false);
	});


    foreach(integer id , sources, ``{
		y2milestone("Enabling source %1", id);
		Pkg::SourceSetEnabled(id, true);
	});

    Pkg::SourceStartManager(true);

    y2milestone("All sources: %1", Pkg::SourceGetCurrent(false));
    y2milestone("Enabled sources: %1", Pkg::SourceGetCurrent(true));

    return;
}

/**
 * Check if there is a language selected in the package manager,
 * if not then select the language used in the UI. Htis prevents the solver
 * from allocating too many resources (see bug #339756)
 */
global void CheckLanguage()
{
    if (Pkg::GetPackageLocale() == "" && Pkg::GetAdditionalLocales() == [])
    {
	y2warning("No language selected, preselecting the current UI language: %1", UI::GetLanguage(true));
	// if there is nothing selected yet then preset the language
	Pkg::SetPackageLocale(UI::GetLanguage(true));
    }
}

/**
 * Set packages to be copied to iso image tree
 * @return boolean
 */
global define boolean setPackages() ``{
    string base = Config["base"]:"";
    list<string> addons = Config["addons"]:[];
    list<string> packages  = Config["packages"]:[];
    list<string> post_packages  = Config["post-packages"]:[];
    string kernel = Config["kernel"]:"";
    list<string> kernels = [];

    if (kernel == "") {
        kernels = [
                   "kernel-64k-pagesize",
                   "kernel-bigsmp",
                   "kernel-debug",
                   "kernel-default",
                   "kernel-smp",
                   "kernel-sn2",
		   "kernel-xen",
                   "kernel-um",
                   "kernel-vanilla"
		   ];

	// add architecture dependent kernels
	// They might be available e.g. on an update source but they shoudln't be
	// added automatically because they might require unavailable packages
	// It can happen probably only on x86_64 when kernel-pae (i386 only)
	// is released on online update source (bnc#421995)
	string arch = GetArch();

	if (arch == "i386")
	{
	    kernels = (list<string>)union(kernels, [
                   "kernel-pae",
		   "kernel-xenpae",
	    ]);
	}
	else if (arch == "s390")
	{
	    kernels = (list<string>)union(kernels, [
                   "kernel-s390",
	    ]);
	}
	else if (arch == "s390x")
	{
	    kernels = (list<string>)union(kernels, [
                   "kernel-s390",
                   "kernel-s390x",
	    ]);
	}
	else if (arch == "ppc64")
	{
	    kernels = (list<string>)union(kernels, [
                   "kernel-iseries64",
                   "kernel-pmac64",
                   "kernel-pseries64",
                   "kernel-ppc64",
	    ]);
	}

    } else {
        kernels = add(kernels, kernel);
    }


    if (Config["type"]:`unknown == `patterns)
    {
	// base pattern
	if (base != "")
	{
	    Pkg::ResolvableInstall(base, `pattern);
	}

	if (size(addons) > 0 )
	{
	    foreach(string p, addons, ``{
		Pkg::ResolvableInstall(p, `pattern);
	    });
	}
    }
    else
    {
	// Base Selection
	if (base!="")
	{
	    Pkg::SetSelection(base);
	}

	// Addons
	if (size(addons) > 0 )
	{
	    foreach(string s, addons, ``{
		Pkg::SetSelection(s);
	    });
	}
    }

    packages = (list<string>) union(packages, post_packages);
    packages = (list<string>)union(packages, kernels);

    y2milestone("Selected packages: %1", packages);

    Pkg::DoProvide(packages);

    CheckLanguage();

    // mark taboo packages
    list<string> taboo_packages = Config["taboo"]:[];

    if (size(taboo_packages) > 0)
    {
	y2milestone("Setting Taboo packages: %1", taboo_packages);
	MarkTaboo(taboo_packages);
    }

    boolean ret = Pkg::PkgSolve(false);

    return (ret);
}

global boolean removeDestination()
{
    string isodir = Config["iso-directory"]:"" + "/"  + Config["name"]:"";
    return (integer)SCR::Execute(.target.bash, sformat("rm -rf -- '%1'", String::Quote(isodir)) ) == 0;
}

global boolean confirmDestinationRemoving()
{
    // popup question, %1 is directory name
    if (Popup::YesNo(sformat(_("Remove the destination directory %1?"), Config["iso-directory"]:"" + "/"  + Config["name"]:"")))
    {
	// remove the destination
	return removeDestination();
    }

    return false;
}

global define boolean verifyDestination() ``{
    string isodir = Config["iso-directory"]:"" + "/"  + Config["name"]:"";
    if ((integer)SCR::Read(.target.size, isodir) > 0 ) { // its a file!

	if (Mode::commandline())
	{
	    CommandLine::Print(sformat(_("The destination %1 already exists."), isodir));

	    // TODO ask in interactive mode

	    return false;
	}
        if (Popup::YesNo(sformat(_("Destination directory exists or is a file.
Remove directory %1?") , isodir)))
	{
	    y2milestone("Removing directory %1", isodir);
	    return removeDestination();
	}
        else
	{
            return false;
	}
    }

    return true;
}

/**
 * Check if selected packages are available
 * @return string error message
 */
global define string checkPackageAvail() ``{

    string error_msg = "";

    Progress::Title(_("Checking for package availability..."));

    list<string> selectedPackages = Pkg::GetPackages (`selected , true);
    y2milestone("Selected %1 packages: %2", size(selectedPackages), sort(selectedPackages));

    list<string> failed = [];
    toCopy = $[];

    map<string,string> versions = listmap (map p, Config["package_versions"]:[], {
      return $[ p["name"]:"" : p["version"]:"" ];
    });

    foreach(string package, selectedPackages, ``{

        string version  = versions[package]:"";

	list<map> package_data_list = Pkg::ResolvableProperties(package, `package, version);
	map package_data = package_data_list[0]:$[];
	if (package_data == nil || package_data == $[])
	{
	    failed = add (failed, package);
	}
	else
	{
	    y2debug("package_data: %1", package_data);
	    string arch =  package_data["arch"]:"noarch";
            // find the package with correct version
            if (version != "")
            {
              package_data      = $[];
              foreach (map data, package_data_list, {
                if (data["arch"]:"" == arch && data["version"]:"" == version)
                  package_data = data;
              });
            }

	    integer src = package_data["source"]:-1;
	    integer medianr = package_data["medium_nr"]:1;

	    list<map> pkglist = toCopy[src, medianr]:[];

	    pkglist = add(pkglist, $["path": package_data["path"]:"", "name": package, "arch": arch]);

	    // add an empty map if the source doesn't exist
	    if (!haskey(toCopy, src))
	    {
		toCopy[src] = $[];
	    }

	    toCopy[src, medianr] = pkglist;
	}
    });
    ProductCreator::missing_packages = failed;
    if (size(failed) > 0 )
    {
	integer num = size(failed);
	error_msg = sformat(_("%1 package not available.", "%1 packages not available.", num), num);
    }
    y2milestone("packages not found: %1", failed);
    y2debug("Evaluated packages toCopy: %1", toCopy);

    return error_msg;
}


global void CallbackSourceReportStart(integer source_id, string url, string task)
{
    y2debug("source_id: %1, url: %2, task: %3", source_id, url, task);
}

global boolean CallbackSourceReportProgress(integer value)
{
    y2debug("progress: %1%%", value);
    return true;
}

global void CallbackSourceReportEnd(integer numeric_id, string url, string task, symbol error, string reason)
{
    y2debug("source_id: %1, url: %2, task: %3, error: %4, reason: %5", numeric_id, url, task, error, reason);
}

global void InitDownload(string task)
{
    y2debug("InitDownload: %1", task);
}

global void DestDownload()
{
    y2debug("DestDownload");
}

global void StartDownload (string url, string localfile)
{
    // reformat the URL
    string url_report = URL::FormatURL(URL::Parse(url), 60);

    if (Mode::commandline()) {
	CommandLine::PrintVerbose(url_report);
    }
    else
    {
	// change the label
	UI::ChangeWidget(`id(`pb), `Label, sformat(_("Copying %1"), url_report));
    }
}


global void StartDownloadEmpty (string url, string localfile)
{
    y2debug("StartDownload: %1", url);
}

global boolean ProgressDownload (integer percent, integer bps_avg, integer bps_current)
{
    return UI::PollInput() != `abort;
}

global void RedirectCallbacks()
{
    Pkg::CallbackSourceReportStart(ProductCreator::CallbackSourceReportStart);
    Pkg::CallbackSourceReportProgress(ProductCreator::CallbackSourceReportProgress);
    Pkg::CallbackSourceReportEnd(ProductCreator::CallbackSourceReportEnd);

    Pkg::CallbackInitDownload (ProductCreator::InitDownload);
    Pkg::CallbackStartDownload (ProductCreator::StartDownload);
    Pkg::CallbackProgressDownload (ProductCreator::ProgressDownload);
    // use the standard callback handler
    Pkg::CallbackDoneDownload (PackageCallbacks::DoneDownload);
    Pkg::CallbackDestDownload (ProductCreator::DestDownload);
}

global void ResetCallbacks()
{
    Pkg::CallbackSourceReportStart(PackageCallbacks::SourceReportStart);
    Pkg::CallbackSourceReportProgress(PackageCallbacks::SourceReportProgress);
    Pkg::CallbackSourceReportEnd(PackageCallbacks::SourceReportEnd);

    Pkg::CallbackInitDownload (PackageCallbacks::InitDownload);
    Pkg::CallbackStartDownload (PackageCallbacks::StartDownload);
    Pkg::CallbackProgressDownload (PackageCallbacks::ProgressDownload);
    Pkg::CallbackDoneDownload (PackageCallbacks::DoneDownload);
    Pkg::CallbackDestDownload (PackageCallbacks::DestDownload);
}

/**
 * CopyPackages()
 * Copy selected package to target tree
 * @param integer id
 * @return boolean
 */
global boolean CopyPackages()
{
    // TODO FIXME get datadir from the source
    string datadir  = "suse";
    string basedir = Config["iso-directory"]:"" + "/" + Config["name"]:"" + "/";

    boolean ret = true;

    y2milestone("Package summary: %1", toCopy);

    Pkg::CallbackStartDownload (ProductCreator::StartDownloadEmpty);

    // copy the packages
    foreach(integer source, map<integer, list<map> > srcmapping, toCopy,
	{
	    foreach(integer medium, list<map> packages, srcmapping,
		{
		    y2milestone("Copying packages from source %1, medium %2", source, medium);

		    foreach(map package, packages,
			{
			    Progress::Title(sformat(_("Copying %1"), package["name"]:"..." ));
			    Progress::NextStep();
			    //string dir = basedir + product_map[source]:"/" + datadir + "/" + package["arch"]:"";
			    string dir = basedir + product_map[source]:"/" + "/" + package["path"]:"";

			    list<string> dir_elements = splitstring(dir, "/");
			    dir_elements = remove(dir_elements, size(dir_elements) - 1);
			    dir = mergestring(dir_elements, "/");

			    if (SCR::Read(.target.dir, dir) == nil )
			    {
				y2milestone("Creating dir: %1", dir);
				SCR::Execute(.target.mkdir , dir);
				y2debug("dir contents: %1", (list)SCR::Read(.target.dir, dir));
			    }

			    y2milestone("downloading package %1...", package["path"]:"");

			    string l_packge = Pkg::SourceProvideFile(source, medium, package["path"]:"");

			    if (l_packge == nil || l_packge == "")
			    {
				Report::Error(sformat(_("Cannot download package %1
 from source %2.
"), package["path"]:"", source));
				ret = false;
				break;
			    }

			    string cpCmd = sformat("cp -a '%1' '%2'", String::Quote(l_packge), String::Quote(dir) );

			    y2debug("%1", cpCmd);

			    any ret = SCR::Execute (.target.bash, cpCmd);
			    if (ret!=0)
			    {
				Popup::Error(_("Error while copying packages. 
		    Check the created directory for possible hints."));
				ret = false;
				break;
			    }
			}
		    );
		}
	    );
	}
    );


    foreach(integer src_ind, string subdir, product_map, {
	    map general_info = Pkg::SourceGeneralData(src_ind);

	    // regenerate the metadata
	    if (general_info["type"]:"" == "YUM")
	    {
		ret = ret && Exec(sformat("/usr/bin/createrepo '%1/%2'", String::Quote(basedir), String::Quote(subdir)));
	    }
	    else
	    {
		// TODO FIXME get datadir from the source
		ret = ret && Exec(sformat("cd '%1/%2/%3' && /usr/bin/create_package_descr -x setup/descr/EXTRA_PROV -M 3",
		    String::Quote(basedir), String::Quote(subdir), String::Quote(datadir)));

		// check if the metadata are gzipped
		boolean compressed_meta = FileUtils::Exists(sformat("%1/%2/%3/setup/descr/packages.DU.gz", basedir, subdir, datadir));
		y2milestone("Compressed metadata: %1", compressed_meta);

		if (compressed_meta)
		{
		    ret = ret && Exec(sformat("cd '%1/%2/%3/setup/descr/' && gzip -9 -f packages packages.DU packages.en",
			String::Quote(basedir), String::Quote(subdir), String::Quote(datadir)));
		}
	    }
	}
    );

    Pkg::CallbackStartDownload (ProductCreator::StartDownload);

    return ret;
}



global define boolean readControlFile(string filename) ``{

    if (profile_parsed)
        return true;
    if (!Profile::ReadXML(filename))
    {
        Report::Error(_("Error reading control file."));
        return false;
    }
    y2debug("Current profile: %1", Profile::current);

    map software = Profile::current["install", "software"]:$[];

    if (size(software) == 0)
    {
	software = Profile::current["software"]:$[];
    }

    y2milestone("Software config: %1", software);

    if (haskey(software, "patterns"))
    {
	y2milestone("Switching to profile based config");
	Config["type"] = `patterns;
	list<string> pats = software["patterns"]:[];
	Config["base"] = pats[0]:"";

	if (size(pats) > 1)
	{
	    Config["addons"] = remove(pats, 0);
	}
    }
    else
    {
	y2milestone("Using selections based config");
	Config["base"] = software["base"]:"";
	Config["addons"] = software["addons"]:[];
    }

    PackageAI::toinstall = software["packages"]:[];
    Config["packages"] = AutoinstSoftware::autoinstPackages();

    // add "post-packages"
    list post_packages = software["post-packages"]:[];
    if (size(post_packages) > 0)
    {
	y2milestone("Adding \"post-packages\": %1", post_packages);
	Config["packages"] = union(Config["packages"]:[], post_packages);
    }

    // TODO: remove also "remove-packages" from the list?
    // Is it safe to remove them due to possible dependencies??

    y2milestone("Config: %1", Config );
    profile_parsed = true;
    return true;
}

/**
 * Constructor
 */
global define void ProductCreator() ``{
    configSetup();
    if (FileUtils::Exists ("/etc/sysconfig/autoinstall"))
	AYRepository = Misc::SysconfigRead( .sysconfig.autoinstall.REPOSITORY,
            "/var/lib/autoinstall/repository/");
}


/* EOF */
}
