/* ------------------------------------------------------------------------------
 * Copyright (c) 2006-2012 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	include/product-creator/dialogs.ycp
 * Package:	Configuration of product-creator
 * Summary:	Dialogs definitions
 * Authors:	Anas Nashif <nashif@suse.de>
 *
 * $Id$
 */

{

    textdomain "product-creator";

    import "FileUtils";
    import "ProductCreator";
    import "Wizard";
    import "SourceManager";
    import "Report";
    import "URL";
    import "Label";
    import "Popup";
    import "URL";
    import "GPG";
    import "GPGWidgets";
    import "CWM";
    import "String";
    import "Package";
    import "Arch";
    import "PackagesUI";

    include "product-creator/routines.ycp";
    include "product-creator/helps.ycp";

    /**
       Create a table item from a map as returned by the InstSrcManager agent.
       @param source The map describing the source as returned form the agent.
       @return An item suitable for addition to a Table.
    */
    term createTableItem( integer source ,
            boolean selectable, 
            string media_filter) {

        // Source data
	map sd = SourceManager::SourceData(source);
	y2milestone("SourceManager:: sources: %1", sd);
	term item = `item();

	map url = URL::Parse(sd["url"]:"");
	if (media_filter == "" || url["scheme"]:"" == media_filter )
	{
	    if (selectable)
		item = `item(
			     `id( source ),
			     "",
			     // corresponds to the "Enable/Disable" button
			     sd["enabled"]:true ? _("On") : _("Off"),
			     sd["alias"]:"",
			     sd["url"]:""
			     );
	    else
		item = `item(
			     `id( source ),
			     // corresponds to the "Enable/Disable" button
			     sd["enabled"]:true ? _("On") : _("Off"),
			     sd["alias"]:"",
			     sd["url"]:""
			     );
	}

	y2debug("Table item for source %1: %2", source, item);
	return item;
    }

    /**
     * Fill sources table with entries from the InstSrcManager agent.
     * @return list list of items
     */
    list<term> fillSourceTable(list<integer> sources, boolean selectable, string media_filter) {
	if (size(sources) == 0 )
	    sources = Pkg::SourceGetCurrent ( false );

        list<term> items = [];

	items = maplist(integer source, sources, ``{
                y2debug("working on source: %1", source);
	        return(createTableItem( source , selectable, media_filter));
	});
        items  = filter(term i, items, ``(i[3]:""!=""));

	return items;

    }

    /**
     * Select package for installation. If package itself is not available, find package providing it
     * If version is not empty, select specific package version
     */
    boolean InstallPackageOrProviderVersion (string p, string version) {

                    y2internal ("p %1, version '%2'", p, version);
		    boolean selected	= (version == "") ?
                      Pkg::PkgInstall(p) :
                      Pkg::ResolvableInstallArchVersion (p, `package, ProductCreator::GetArch(), version);

		    y2milestone("selecting package for installation: %1 -> %2", p, selected);
		    if (!selected)
		    {
			list <list> provides	= Pkg::PkgQueryProvides (p);
			provides	= filter (list l, provides, {
			    return l[1]:`NONE != `NONE;
			});
			string pp	= provides[0,0]:"";
			if (pp != "")
			{
			    y2milestone("selecting first package providing %1: %2 -> %3", p, pp, Pkg::PkgInstall (pp));
			}
		    }

    }

    boolean InstallPackageOrProvider (string p) {
      return InstallPackageOrProviderVersion (p, "");
    }


    /**
     * General configuration dialog
     * @return dialog result
     */
    define symbol Configure1Dialog () ``{

        /* ProductCreator configure1 dialog caption */
        string caption = _("Product Creator Configuration");


        string name = ProductCreator::Config["name"]:"";
        string pkgtype = ProductCreator::Config["pkgtype"]:"package-manager";

        // Autoyast
        string profile = ProductCreator::Config["profile"]:"";
        boolean copy_profile = ProductCreator::Config["copy_profile"]:false;


        // List
        string plain_list = ProductCreator::Config["package-list"]:"";


        term c2 = `HBox (
            `HWeight (10, `Empty ()),
            `HWeight (80, `VBox (
		`VSquash (`HBox (
		    `InputField (`id(`profile_loc), `opt (`hstretch),
			// text entry label
			_("Profile Loca&tion:"), profile),
                    `VBox (
			`VSpacing (),
			`Bottom (
			    // push button label
			    `PushButton (`id (`open_profile), _("Select Fi&le"))
			)
                    )
                )),
		`Left (
		    `CheckBox (`id(`copyprofile),
			// check box label
			_("Copy Profile to CD I&mage"), copy_profile)
		)
            ))
        );

        term v =
            `VBox (
                    // radio button label
                    `Left (`RadioButton (`id (`pkgmgr), `opt (`notify), _("Pac&kage Manager"), pkgtype == "package-manager")),
                    // radio button label
                    `Left (`RadioButton (`id (`autoyast), `opt (`notify), _("&AutoYaST Control File"), pkgtype == "autoyast")),
                    c2
                  );


        list sources = []; // ProductCreator::GetDirSources(source);
        /* ProductCreator configure1 dialog contents */
        term contents = `HVSquash (
	    `VBox (
		`InputField(`id(`name), `opt (`hstretch),
		    // text entry label
		    _("&Configuration Name:"), name),
		// frame label
                `Frame (_("Packages"), `VBox (
		    `RadioButtonGroup (`id (`pkg), v)
                ))
            )
        );

        Wizard::SetContentsButtons(caption, contents, HELPS["initial"]:"",
                Label::BackButton(), Label::NextButton());



        any ret = nil;
        symbol rb =`none;
        while(true) {

            rb = (symbol) UI::QueryWidget (`id (`pkg), `CurrentButton );

            if (rb  == `autoyast)
            {
                UI::ChangeWidget (`id(`profile_loc), `Enabled, true);
                UI::ChangeWidget (`id(`open_profile), `Enabled, true);
                UI::ChangeWidget (`id(`copyprofile), `Enabled, true);
            }
            else if (rb == `plain )
            {
                UI::ChangeWidget (`id(`profile_loc), `Enabled, false);
                UI::ChangeWidget (`id(`open_profile), `Enabled, false);
                UI::ChangeWidget (`id(`copyprofile), `Enabled, false);
            }
            else  {
                UI::ChangeWidget (`id(`profile_loc), `Enabled, false);
                UI::ChangeWidget (`id(`open_profile), `Enabled, false);
                UI::ChangeWidget (`id(`copyprofile), `Enabled, false);
            }

            ret = UI::UserInput();



            /* abort? */
            if(ret == `abort || ret == `cancel) {
                if(ProductCreator::ReallyAbort()) break;
                else continue;
            }
            else if(ret == `next ) {

		// set architecture if configured
		string arch = ProductCreator::Config["arch"]:"";
		if (arch != nil && arch != "")
		{
		    ProductCreator::SetPackageArch(arch);
		}

                string name = (string)UI::QueryWidget(`id(`name), `Value);

                if (name == "")
                {
                    Report::Error(_("Enter the name of the configuration."));
                    continue;
                }
                if (haskey(ProductCreator::Configs, name) &&
                        ProductCreator::Config["name"]:"" != name)
                {
                    Report::Error(_("A configuration with this name already exists.
                                Select a new name.
"));
                                continue;
                }


                ProductCreator::Config["old_name"] = ProductCreator::Config["name"]:"";
                ProductCreator::Config["name"] = name;



                if (rb  == `autoyast)
                {
		    string profile_loc	= (string)UI::QueryWidget(`id(`profile_loc), `Value);
		    if (!FileUtils::Exists (profile_loc))
		    {
			// error message
			Report::Error (sformat (_("The file '%1' does not exist. Choose a correct one."), profile_loc));
			continue;
		    }
                    ProductCreator::Config["pkgtype"] = "autoyast";
                    ProductCreator::Config["profile"] = profile_loc;
                    ProductCreator::Config["copy_profile"] = (boolean)UI::QueryWidget(`id(`copyprofile), `Value);
                }
                else  {
                    ProductCreator::Config["pkgtype"] = "package-manager";
                }
                ProductCreator::modified = true;
                ProductCreator::profile_parsed = false;
                break;
            }
            else if ( ret == `back)
            {
                break;
            }
            else if (ret ==`open_profile)
            {
                any new_file = UI::AskForExistingFile( ProductCreator::AYRepository , "*", _("Select File"));
                if (new_file != nil)
                {
                    UI::ChangeWidget(`id(`profile_loc), `Value, (string)new_file);
                }
                continue;
            }
            else {
		if (ret != `autoyast && ret != `pkgmgr)
		    y2error("unexpected retcode: %1", ret);
                continue;
            }
        }

        return (symbol)ret;
    }

    // remember the direction to correctly skip baseProductSelectionDialog()
    boolean going_back = false;

    /**
     * Configure2 dialog
     * @return dialog result
     */
    define symbol Configure2Dialog () ``{

        // ProductCreator configure2 dialog caption
        string caption = _("Product Creator Configuration");

        string dirtree = ProductCreator::Config["iso-directory"]:"";
        string publisher = ProductCreator::Config["publisher"]:"";
        string preparer = ProductCreator::Config["preparer"]:"";
        string result = ProductCreator::Config["result"]:"iso";
        string isofile_path = ProductCreator::Config["isofile"]:"";
        boolean savespace = ProductCreator::Config["savespace"]:false;

        if (isofile_path == "")
        {
            isofile_path = ProductCreator::Config["name"]:"" + ".iso";
        }

        /* ProductCreator configure2 dialog contents */
        term contents = `HVSquash (`VBox (
	    // frame label
            `Frame (_("Output:"), `VBox(
		`VSquash (`HBox (
		    `InputField (`id(`dirtree), `opt (`hstretch),
			// text entry label
			_("&Path to Generated Directory Tree:"), dirtree),
                    `VBox (
			`VSpacing (),
			`Bottom (
			    // push button label
			    `PushButton (`id(`open_dir), _("&Select Directory"))
			)
                    )
                )),
		`RadioButtonGroup (`id(`result), `VBox (
		    `Left (`RadioButton(`id(`isofile),`opt (`notify),
			// radio button label
			_("&Generate ISO Image File"), result == "iso"
		    )),
                    `HBox (
			`HWeight (10, `Empty()),
                        `HWeight (80, `VBox (
			    `HBox (
				`HWeight (2, `InputField (`id(`isofile_path),
				    `opt (`hstretch),
				    // text entry label
				    _("&ISO Image File:"), isofile_path
				)),
                                `HWeight (1, `Empty ())
                            )
                        ))
		    ),
		    `Left (`RadioButton(`id(`directory), `opt (`notify),
			// radio button label
			_("Create Directory &Tree Only"), result == "tree"
		    ))
                ))
            )),
            `VSpacing(1),
	    // frame label
	    `Frame (_("Other Options"), `VBox (
		`Left (`CheckBox (`id (`savespace),
		    // check box label
		    _("Copy only needed files to save space."), savespace
		)),
		`VSpacing (),
		`Left (`InputField (`id (`pub), `opt (`hstretch),
		    // text entry label
		    _("CD Publisher:"), publisher
		)),
                `Left (`InputField (`id(`prep), `opt (`hstretch),
		    // text entry label
		    _("CD Preparer:"), preparer
		))
	    ))

        ));

        Wizard::SetContentsButtons(caption, contents, HELPS["dest"]:"",
            Label::BackButton(), Label::NextButton()
	);

        any ret = nil;
        while(true) {
	    symbol rb = (symbol)UI::QueryWidget(`id(`result), `CurrentButton);

	    if (rb == `isofile)
	    {
		UI::ChangeWidget(`id(`isofile_path), `Enabled, true);
	    }
            else
            {
		UI::ChangeWidget(`id(`isofile_path), `Enabled, false);
	    }

	    ret = UI::UserInput();

	    // abort?
            if(ret == `abort || ret == `cancel) {
		if(ProductCreator::ReallyAbort()) break;
                else continue;
            }
            else if (ret ==`open_dir)
	    {
		any new_dir = UI::AskForExistingDirectory (dirtree,
		    // ask for directory widget label
		    _("Select Directory"));
                if (new_dir != nil)
                {
		    UI::ChangeWidget(`id(`dirtree), `Value, (string) new_dir);
		}
                continue;
            }
            else if (ret == `back)
            {
		going_back = true;
                break;
            }
            else if (ret == `next)
	    {
		string isodir = (string) UI::QueryWidget(`id(`dirtree), `Value);
                if (isodir == "")
                {
		    // error popup
		  Report::Error(_("Path to generated directory tree missing."));
		    continue;
                }
                else
                {
		    ProductCreator::Config["iso-directory"] = isodir;
                }
		if (rb  == `isofile)
                {
		    ProductCreator::Config["result"]	= "iso";
                    ProductCreator::Config["isofile"]	=
			(string)UI::QueryWidget(`id(`isofile_path), `Value);
		}
                else
		{
		    ProductCreator::Config["result"]	= "tree";
		}
		ProductCreator::Config["savespace"]	=
		    (boolean)UI::QueryWidget (`id (`savespace), `Value);
                ProductCreator::Config["publisher"]	=
		    (string) UI::QueryWidget (`id (`pub), `Value);
                ProductCreator::Config["preparer"]	=
		    (string) UI::QueryWidget (`id (`prep), `Value);
                break;
            }
            else if (ret != `directory && ret != `isofile)
	    {
		y2error("unexpected retcode: %1", ret);
                continue;
	    }
        }
	return (symbol)ret;
    }

string AskArch(string label, list<string> archs, string preselected)
{
    term widget1 = `VBox();
    term widget2 = `VBox();

    const integer max_lines = 6;

    if (!contains(archs, preselected))
    {
	y2warning("The preselected architecture is missing in the list!");
	// add the missing preselected arch
	archs = prepend(archs, preselected);
    }

    integer archsz = size(archs);
    integer col1num = (archsz > max_lines) ? (archsz + 1) / 2 : archsz;
    y2milestone("Number of archs in the first column: %1", col1num);

    // preselect the first item
    foreach(string a, archs,
	{
	    if (col1num > 0)
	    {
		widget1 = add(widget1, `MinWidth(10, `Left(`RadioButton(`id(a), a, a == preselected))));
	    }
	    else
	    {
		widget2 = add(widget2, `MinWidth(10, `Left(`RadioButton(`id(a), a, a == preselected))));
	    }

	    col1num = col1num - 1;
	}
    );

    term content = `MarginBox(1, 0.5,
	`VBox(
	    `Label(label),
	    `VSpacing(1),
	    `Frame(_("Target Architecture"),
		`RadioButtonGroup(`id(`rb),
		    `HBox(
			`Top(widget1),
			`HStretch(),
			`Top(widget2),
			`HStretch()
		    )
		)
	    ),
	    `VSpacing(1),
	    `HBox(
		`HSpacing(`opt(`hstretch), 2),
		`HWeight(1, `PushButton(`id(`ok), Label::OKButton())),
		`HSpacing(2),
		`HWeight(1, `PushButton(`id(`cancel), Label::CancelButton())),
		`HSpacing(`opt(`hstretch), 2)
	    )
	)
    );

    UI::OpenDialog(content);

    any ui = UI::UserInput();
    string ret = (string)UI::QueryWidget(`id(`rb), `CurrentButton);

    UI::CloseDialog();

    if (ui == `cancel || ui == `close)
    {
	// canceled
	return nil;
    }
    else if (ui == `ok)
    {
	y2milestone("Selected architecture: %1", ret);
	return ret;
    }
    else
    {
	y2error("Unhandled user input %1", ui);
	return nil;
    }
}


boolean CheckArchitecture(integer SrcID)
{
    map general_info = Pkg::SourceGeneralData(SrcID);
    y2milestone("Checking architecture of repository %1", general_info);
    boolean found_architecture = false;
    list<string> found_archs = [];

    string arch = ProductCreator::GetPackageArch();

    if (arch == nil)
    {
	arch = ProductCreator::GetArch();
    }

    if (arch == "s390_64") arch = "s390x";

    string type = general_info["type"]:"";

    // if the type is missing then probe it now
    if (type == "NONE")
    {
	type = Pkg::RepositoryProbe(general_info["url"]:"", general_info["product_dir"]:"/");
	y2milestone("Probed repository type: %1", type);
    }

    // architecture check is possible only for YaST sources
    if (type == "YaST")
    {
	// Check architecture
	map<string,string> read_content = ProductCreator::ReadContentFile(SrcID);
	y2milestone("content file: %1", read_content);

	foreach(string key, string value, read_content,
	    {
		if (key == "ARCH." + arch)
		{
		    found_architecture = true;
		    break;
		}
		if (key == "BASEARCHS")
		{
		    y2milestone("BASEARCHS: %1", value);
		    list<string> arch_list = splitstring(value, " ");
		    arch_list = filter(string a, arch_list, {return a != nil && a != "";});
		    y2milestone("Found architectures: %1", arch_list);

		    if (contains(arch_list, arch))
		    {
			found_architecture = true;
			break;
		    }
		    else
		    {
			found_archs = (list<string>)union(found_archs, arch_list);
		    }
		}
		else
		{
		    string found_arch = regexpsub(key, "ARCH\\.(.*)", "\\1");

		    if (found_arch != nil)
		    {
			found_archs = add(found_archs, found_arch);
		    }
		}
	    }
	);
    }
    else
    {
	y2milestone("Not a YaST source, cannot verify the architecture");
	found_architecture = true;
    }

    y2milestone("Architecture %1 is supported: %2", arch, found_architecture);

    if (found_architecture)
    {
	return true;
    }
    else
    {
	y2milestone("Supported architectures: %1", found_archs);

	if (size(found_archs) == 0)
	{
	    y2milestone("The repository does not provide architecture data, assuming it is compatible");
	    return true;
	}

	// the architecture is different, ask to switch it
	// %1 is URL of the repository
	// %2 is name of the architecture (like i386, x86_64, ppc...)
	string new_arch = AskArch(
	    sformat(_("Source %1
does not support the current target architecture (%2).
Change the target architecture?
"), general_info["url"]:"", ProductCreator::GetArch()),
	found_archs, found_archs[0]:"");

	// nil == switch has been canceled
	if (new_arch != nil)
	{
	    // change the architecture
	    ProductCreator::SetPackageArch(new_arch);
	    return true;
	}
    }

    return false;
}


    /**
     * Dialog for selecting the sources
     * @return symbol
     */
    define symbol sourceDialog() ``{

        /* dialog caption */
        string caption = _("Source Selection");

        SourceManager::ReadSources();
        list sources = fillSourceTable([], true , "");
        y2debug("sources: %1", sources);

        term table =
            `Table( `id( `table ), `opt( `keepSorting, `notify ),
                    `header(_("Selected"),  _("Status"), _("Name"), _("URL") ),
                    sources
                  );


        term buttons =
	    `VBox(
		`HBox(
		    `ReplacePoint(`id(`rp),
			`Label(sformat(_("Target architecture: %1"), ProductCreator::GetArch()))
		    ),
		    `HSpacing(2),
		    `PushButton(`id(`arch), Label::EditButton())
		),
		`VSpacing(0.3),
		`HBox(
			`PushButton(`id(`select), Label::SelectButton() ),
			`PushButton(`id(`remove), Label::RemoveButton() ),
			// push button label
			`PushButton(`id(`create), _("Cr&eate New..."))
		     )
	    );


        term contents =
	    `VBox(
		table,
		`VSpacing(0.5),
		buttons
	    );

        Wizard::SetContentsButtons(caption, contents, HELPS["sourceDialog"]:"",
                Label::BackButton(), Label::NextButton());


        list<integer> selected_items = ProductCreator::UrlToId(ProductCreator::Config["sources"]:[]);

	// remove not found sources (with id = -1)
	selected_items = filter(integer source_id, selected_items, {return source_id >= 0;});

	foreach(integer i, selected_items, {
            UI::ChangeWidget(`id(`table), `Item(i, 0) , _("X"));
        });

	// report unavailbale sources if any
	ProductCreator::CheckUnavailableSources();

        any ret = nil;


        while(true) {
            ret = UI::UserInput();
	    if (ret == `table)
	    {
		integer ID = (integer)UI::QueryWidget(`id(`table),`CurrentItem);
		ret = contains (selected_items, ID) ? `remove : `select;
	    }
            /* abort? */
            if(ret == `abort || ret == `cancel) {
                if(ProductCreator::ReallyAbort()) break;
                else continue;
            }
            else if (ret == `select)
            {
                integer SrcID = (integer)UI::QueryWidget(`id(`table), `CurrentItem);

		boolean repo_ok = CheckArchitecture(SrcID);

		if (repo_ok)
		{
		    if (!contains(selected_items, SrcID))
		    {
			selected_items = add (selected_items, SrcID );

			map general_info = Pkg::SourceGeneralData(SrcID);

			// enable the source
			if (general_info["enabled"]:false)
			{
			    Pkg::SourceSetEnabled(SrcID, true);
			}
		    }

		    UI::ChangeWidget(`id(`table), `Item(SrcID, 0) , _("X"));

		    // refresh the target architecture if it has been changed
		    if (ProductCreator::GetPackageArch() != nil)
		    {
			UI::ReplaceWidget(`rp,
			    `Label(sformat(_("Target Architecture: %1"), ProductCreator::GetPackageArch()))
			);
		    }
		}
            }
            else if (ret == `remove)
            {
                integer SrcID = (integer)UI::QueryWidget(`id(`table), `CurrentItem);
		map general_info = Pkg::SourceGeneralData(SrcID);

		// disable the source
		if (general_info["enabled"]:false)
		{
		    Pkg::SourceSetEnabled(SrcID, false);
		}

                selected_items = filter(integer i, selected_items, ``(SrcID!=i ));
                UI::ChangeWidget(`id(`table), `Item(SrcID, 0) , "");
            }
	    else if (ret == `create)
	    {
		if (Package::Install ("yast2-add-on-creator"))
		{
		    symbol createret = (symbol)WFM::CallFunction ("add-on-creator", []);
		    if (createret == `next)
		    {
			map ex = (map)WFM::CallFunction ("add-on-creator_auto", [ "Export" ]);
			string product_path	= ex["product_path"]:"";
			if (product_path != "")
			{
			    string url = ex["iso"]:false ?  "file://" : "dir://";
			    if (Pkg::SourceCreate (url + product_path, "") != -1)
			    {
				SourceManager::ReadSources();
				list<term> sources = fillSourceTable([], true , "");
				UI::ChangeWidget (`id (`table), `Items, sources);
				foreach (term source, sources, {
				    integer SrcID = source[0,0]:-1;
				    if (SrcID != -1 && contains (selected_items, SrcID))
				    {
					UI::ChangeWidget (`id(`table), `Item(SrcID, 0) , _("X"));
				    }
				});
				Pkg::SourceSaveAll ();
			    }
			}
		    }
		}
	    }
            else if(ret == `next)
            {
                y2milestone("selected items: %1", selected_items);
                ProductCreator::Config["sources"] = ProductCreator::getSourceURLs(selected_items);
                y2milestone("sources: %1", ProductCreator::Config["sources"]:[] );
                if (size(ProductCreator::Config["sources"]:[])  == 0 )
                {
                    Report::Error(_("Select at least one source."));
                    continue;
                }

		string arch = ProductCreator::GetPackageArch() ;

		if (arch != nil)
		{
		    y2milestone("Target architecture has been changed to %1", arch);
		    ProductCreator::Config["arch"] = arch;

		    boolean check_ok = true;
		    boolean arch_changed = false;

		    do
		    {
			string ar = ProductCreator::GetPackageArch();
			check_ok = true;
			arch_changed = false;

			// all selected sources should be refreshed
			// check archs onece again (needed after switching architecture multiple times)
			foreach(integer src, selected_items,
			    {
				if (!CheckArchitecture(src))
				{
				    check_ok = false;
				    break;
				}

				arch_changed = arch_changed || (ar != ProductCreator::GetPackageArch());
			    }
			);
		    }
		    while(arch_changed);

		    if (!check_ok)
		    {
			// error message
			Report::Error(_("There is a mismatch between the selected
repositories and the machine architecture.

Either select a different repository or
change the target architecture.
"));

			// don't leave the dialog
			continue;
		    }

		    // temporarily initialize the target, read trusted GPG keys (needed for refresh)
		    Pkg::TargetInit("/", false);

		    foreach(integer src, selected_items,
			{
			    Pkg::SourceForceRefreshNow(src);
			}
		    );

		    // reload repositories
		    Pkg::SourceFinishAll();
		    Pkg::SourceStartManager(false);

		    // finish the target
		    Pkg::TargetFinish();
		}

		going_back = false;

                break;
            }
            else if( ret == `back) {
                break;
            }
	    else if (ret == `arch)
	    {
		// ask for the target architecture
		string pkg_arch = ProductCreator::GetPackageArch();

		if (pkg_arch == nil)
		{
		    pkg_arch = Pkg::SystemArchitecture();
		}

		string new_arch = AskArch(
		    _("Select the new target architecture."),
		    // sort the list according to the current locale
		    lsort(["i386", "i486", "i586", "i686", "sparc", "sparc64", "mips", "mips64", "ppc", "ppc64", "alpha",
			"s390", "s390x", "ia64", "x86_64"]),
		    pkg_arch);

		// nil == switch has been canceled
		if (new_arch != nil && new_arch != "" && new_arch != pkg_arch)
		{
		    // change the architecture
		    ProductCreator::SetPackageArch(new_arch);

		    UI::ReplaceWidget(`rp,
			`Label(sformat(_("Target Architecture: %1"), ProductCreator::GetPackageArch()))
		    );
		}
	    }
            else {
                y2error("unexpected retcode: %1", ret);
                continue;
            }
        }

        return (symbol)ret;
    }

    string ProductFromRepo(integer repo_id)
    {
	map<string,string> read_content = ProductCreator::ReadContentFile(repo_id);
	string prod_name = read_content["LABEL"]:"";

	y2milestone("Product name: %1", prod_name);
	return prod_name;
    }

    string ProductFromURL(string url)
    {
        integer src_id = ProductCreator::UrlToId([url])[0]:-1;
	y2milestone("Reading product name from src %1", src_id);
	string prod_name = ProductFromRepo(src_id);

	return prod_name;
    }

    define symbol baseProductSelectionDialog()
    {
	if (size(ProductCreator::Config["sources"]:[]) == 1)
	{
	    // there is just one repository, we can skip this dialog
	    y2milestone("Only one repository selected, skipping base repository selection");

	    // remove the option if it exists
	    if (haskey (ProductCreator::Config, "base_repo"))
		ProductCreator::Config = remove(ProductCreator::Config, "base_repo");
	    symbol ret = going_back ? `back : `next;

	    if (ret == `next)
	    {
		ProductCreator::Config["product"] = ProductFromURL((ProductCreator::Config["sources"]:[])[0]:"");
	    }

	    return ret;
	}

        /* dialog caption */
        string caption = _("Base Source Selection");

	string base_url = ProductCreator::Config["base_repo"]:"";
	y2milestone("Base product: %1", base_url);

	// convert the URL to Id
        integer default_base = ProductCreator::UrlToId([base_url])[0]:-1;

	if (default_base < 0)
	{
	    y2milestone("The base repository is unknown, proposing...");
	    default_base = ProductCreator::checkProductDependency();
	}

	string default_url = Pkg::SourceGeneralData(default_base)["url"]:"";

	list<term> items = [];

	foreach(string srcurl, ProductCreator::Config["sources"]:[],
	    {
		items = add(items, `item(srcurl, srcurl == default_url));
	    }
	);

        term contents = `SelectionBox(`id(`base_selection), _("Selected Base Source"), items);

        Wizard::SetContentsButtons(caption, contents, HELPS["baseSelection"]:"",
                Label::BackButton(), Label::NextButton());

        symbol ret = `again;
	string base = "";

        while(!contains([`next, `back, `abort], ret))
	{
            ret = (symbol)UI::UserInput();

	    if (ret == `next)
	    {
		// get the selected source
		base = (string)UI::QueryWidget(`id(`base_selection), `CurrentItem);
		y2internal("Selected base product: %1", base);

		integer base_src_id =  ProductCreator::UrlToId([base])[0]:-1;
		map<string,any> boot_info = ProductCreator::GetBootInfoRepo(base_src_id);
		boolean bootable = boot_info["bootable"]:false;

		// is the base source bootable?
		if (!bootable)
		{
		    y2warning("Selected base product is not bootable");

		    if (!Popup::ContinueCancel("The selected base repository doesn't contain /boot directory.
The created medium will not be bootable.\n"))
		    {
			ret = `again;
		    }
		}
	    }

	    if (ret == `close)
	    {
		ret = `abort;
	    }
	}

	if (ret == `next)
	{
	    ProductCreator::Config["base_repo"] = base;
	    ProductCreator::Config["product"] = ProductFromURL(base);
	}

	return ret;
    }

    /**
     * Configure3 dialog
     * @return dialog result
     */
    define symbol isolinuxDialog () ``{

        /* dialog caption */
        string caption = _("Product Creator Configuration");


        string isolinux = ProductCreator::Readisolinux();

        // FIXME: Manage files for other archs
        string bootconfig = "isolinux.cfg";

        term contents =
                    `VBox(
                        `MultiLineEdit(`id(`isolinux),
                            sformat(_("File Contents: %1"), bootconfig),
                            isolinux
                            ),
                        `PushButton(`id(`loadfile), _("Load File"))
                        );


        Wizard::SetContentsButtons(caption, contents, HELPS["bootconfig"]:"",
                Label::BackButton(), Label::NextButton());

        any ret = nil;
        while(true) {
            ret = UI::UserInput();
            /* abort? */
            if(ret == `abort || ret == `cancel) {
                if(ProductCreator::ReallyAbort()) break;
                else continue;
            }

            else if (ret ==`loadfile)
            {
                any new_file = UI::AskForExistingFile( "" , "*", _("Select File"));
                if (new_file != nil)
                {
                    if (SCR::Read(.target.size, new_file)> 0)
                    {
                        string file = (string)SCR::Read(.target.string, new_file );
                        UI::ChangeWidget(`id(`isolinux), `Value, (string)file);
                    }
                }
                continue;
            }
            else if(ret == `next) {
                string isolinux_new = (string)UI::QueryWidget(`id(`isolinux), `Value);
                ProductCreator::Config["bootconfig"] = isolinux_new;
		y2milestone("Isolinux config: %1", isolinux_new);

                break;
            }
            else if( ret == `back) {
                break;
            }
            else {
                y2error("unexpected retcode: %1", ret);
                continue;
            }
        }

        if (ProductCreator::Config["profile"]:""!="" && ret == `next)
            return `autoyast;
        return (symbol)ret;
    }

    symbol autoyastPackages ()
    {
        string base_selection = "";
        //Pkg::TargetFinish ();
        Popup::ShowFeedback(_("Reading data from Package Database..."), _("Please wait..."));

        Pkg::TargetFinish ();
        string tmp = (string)SCR::Read( .target.tmpdir );
        SCR::Execute(.target.mkdir, tmp + "/tmproot");
        Pkg::TargetInit( tmp + "/tmproot" , true);

        boolean  success =  ProductCreator::EnableSource();

        // Pkg::SourceStartManager(true);

        if (ProductCreator::Config["profile"]:""!= "" && ! ProductCreator::profile_parsed)
        {
            if(!ProductCreator::readControlFile(ProductCreator::Config["profile"]:""))
                return `overview;
            // set the new selection
            y2debug("Config: %1", ProductCreator::Config );

	    if (ProductCreator::Config["type"]:`unknown == `patterns)
	    {
		string base_pat = ProductCreator::Config["base"]:"";

		if (size(base_pat) > 0)
		{
		    Pkg::ResolvableInstall(base_pat, `pattern);
		    y2milestone("Selecting pattern: %1", base_pat);
		}

		if (size(ProductCreator::Config["addons"]:[]) > 0)
		{
		    foreach(string addon, ProductCreator::Config["addons"]:[], ``{
			    Pkg::ResolvableInstall(addon, `pattern);
			    y2milestone("Selecting pattern: %1", addon);
		    });
		}
	    }
	    else
	    {
		y2warning("Unsupported software selection type: %1", ProductCreator::Config["type"]:`unknown);
	    }

            if (size(ProductCreator::Config["packages"]:[] ) > 0)
            {
                map<string,string> versions = listmap (map p, ProductCreator::Config["package_versions"]:[], {
                  return $[ p["name"]:"" : p["version"]:"" ];
                });

                foreach(string p, ProductCreator::Config["packages"]:[], ``{
                    string version = versions[p]:"";
                    if (version != "")
                    {
                      y2milestone("selecting package for installation: %1 (%2) -> %3",
                        p, version, InstallPackageOrProviderVersion (p, version));
                    }
                    else
                    {
                      y2milestone("selecting package for installation: %1 -> %2", p, Pkg::PkgInstall(p));
                    }
                });
            }

	    // mark taboo packages
	    ProductCreator::MarkTaboo(ProductCreator::Config["taboo"]:[]);

            Pkg::PkgSolve(true);

            list allpacs = Pkg::GetPackages(`selected, true);
            y2milestone("All packages: %1 ( %2 )", allpacs, size(allpacs));
        }
        Popup::ClearFeedback();
        return `next;
    }

    /**
     * Start the detailed package selection. If 'mode' is non-nil, it will be
     * passed as an option to the PackageSelector widget.
     *
     * Returns `accept or `cancel .
     **/
    symbol detailedSelection( symbol mode )
    {
	// Open empty dialog for instant feedback

	UI::OpenDialog(`opt(`defaultsize),
		       `ReplacePoint(`id( `rep),
				     `Label( _("Reading package database...") )
				     )
		       );

	// This will take a while: Detailed package data are retrieved
	// while the package manager is initialized
	UI::ReplaceWidget(`rep,
			  mode == nil ?
			  `PackageSelector(`id(`packages)) :
			  `PackageSelector(`id(`packages), `opt(mode))
			  );

	symbol result = (symbol) UI::RunPkgSelection(`id(`packages ) );
	UI::CloseDialog();
	y2milestone( "Package selector returned  %1", result );

	return result;
    }

    /**
     * Start the pattern selection dialog. If the UI does not support the
     * PatternSelector, start the detailed selection with "selections" as the
     * initial view.
     **/
    symbol patternSelection()
    {
	if ( ! UI::HasSpecialWidget(`PatternSelector ) ||
	     UI::WizardCommand(`Ping() ) != true	 )
	{
	    return detailedSelection( nil );	// Fallback: detailed selection
	}

	// switch to packager textdomain, reuse the translations

	// Help text for software patterns / selections dialog
        string helptext = _("<p>
Select one of the following <b>base</b> selections and click <i>Detailed<i> to add
more <b>add-on</b> selections and packages.
</p>");

	Wizard::SetContents(
			    /* dialog caption */
			    _("Software Selection"),
			    `PatternSelector(`id(`patterns ) ),
			    helptext,
			    true,	// has_back
			    true );	// has_next

	Wizard::SetDesktopIcon( "sw_single" );

	symbol result = nil;

	repeat
	{
	    result = (symbol) UI::RunPkgSelection(`id(`patterns ) );
	    y2milestone( "Pattern selector returned %1", result );

	    if ( result == `details )
	    {
		result = detailedSelection( nil );

		if ( result == `cancel )
		    // don't get all the way out - the user might just have
		    // been scared of the gory details.
		    result = nil;

	    }

	} until ( result == `cancel || result == `accept );

	if (result == `accept)
	{
	    result = `next;
	}

	return result;
    }

    /**
     * Display package selection dialog with preselected packages.
     * See runPackageSelector
     * @param versions map of specific package versions that need to be selected
     */
    map<string,any> runPackageSelectorVersions (string base_pattern, list<string> patterns, list<string> packages, map<string,string> versions, list<string> taboo, symbol mode)
    {
	y2milestone("running package selector: base_pattern: %1, patterns: %2, packages: %3, versions: %4 taboo: %5, mode: %6", base_pattern, patterns, packages, versions, taboo, mode);

        any ret = nil;

	Pkg::ResolvableNeutral ("", `package, true);
	Pkg::ResolvableNeutral ("", `pattern, true);

	// set a mount point - there is no use to display DU of the current system
	Pkg::TargetInitDU([ $[ "name" : "/",
	    "free" : ProductCreator::max_size_mb * 1024,
	    "used" : 0, "readonly" : false ]
	]);

        /* dialog caption */
        string caption = _("Software Selection");

        string helptext = _("<p>
Select one of the following <b>base</b> selections and click <i>Detailed<i> to add
more <b>add-on</b> selections and packages.
</p>");
        Pkg::TargetFinish ();


        Popup::ShowFeedback(_("Reading data from Package Database..."), _("Please wait..."));
        ProductCreator::enableSources();

        Popup::ClearFeedback();


        Wizard::CreateDialog();
        Wizard::SetDesktopTitleAndIcon("product-creator");

        string base_selection = "";

        Wizard::SetContents(caption,
                `HVCenter(`Label(_("Reading package database..."))),
                helptext, false, true);

	list<string> addons = patterns;

	// ensure that a langugage is selected
	ProductCreator::CheckLanguage();

	if (size(addons) > 0 || ProductCreator::Config["base"]:"" != "")
	{
	    y2milestone("base pattern: %1, addons: %2", base_pattern, addons);

	    // select the base pattern
	    if (base_pattern != "")
	    {
		Pkg::ResolvableInstall(base_pattern, `pattern);
	    }

	    // select the addons
	    foreach(string addon, addons,
	    {
		Pkg::ResolvableInstall(addon, `pattern);
	    });

	    // mark taboo packages
	    ProductCreator::MarkTaboo(taboo);

	    Pkg::PkgSolve(true);

	}

	// add extra packages
	if (size(packages) > 0)
	{
	    foreach(string p, packages,
	    {
                InstallPackageOrProviderVersion (p, versions[p]:"");
	    });
	}

	y2milestone("package selection mode: %1", mode);

	if (mode == `packages)
	{
	    ret = detailedSelection(nil);
	}
	else if (mode == `patterns)
	{
	    ret = patternSelection();
	}
	else
	{
	    y2error("Unknown mode parameter: %1", mode);
	}

        y2milestone("Selected packages: %1 ", size(Pkg::GetPackages(`selected, true)));

	// activate the selections
        boolean solved = (ret == `cancel || Pkg::PkgSolve(true));

	if (!solved)
	{
	    string details = (string)SCR::Read(.target.string, "/var/log/YaST2/badlist");
	    // error message, %1 = details
	    Report::LongError(sformat(_("Dependencies cannot be resolved.

%1
"), details));
	    Wizard::CloseDialog();
	    return $["ui" : `failed];
	}

        list allpacs = Pkg::GetPackages(`selected, true);
        y2milestone("All packages: %1 ( %2 )", allpacs, size(allpacs));

        list seladd = [];
        list selbase = [];
        if ( ret != `back && ret != `cancel)
        {
	    // do not return patterns selected by dependencies
	    foreach (map pat, Pkg::ResolvableProperties ("", `pattern, ""),
	    {
		y2debug("Processing pattern: %1", pat);
		if (pat["status"]:`none == `selected)
		{
		    string pat_name = pat["name"]:"";
		    y2milestone ("pat %1 selected by %2" , pat_name, pat["transact_by"]:nil);

		    if (pat["transact_by"]:nil != `solver)
			seladd	= add (seladd, pat_name);

		    if (pat["category"]:"" == "base")
		    {
			selbase = add(selbase, pat_name);
		    }
		}
	    });
        }
        else
        {
            seladd = patterns;
            selbase = [base_pattern];
        }

	map<string,any> ret_map = $[];

        ret_map["packages"] = Pkg::FilterPackages(false, true, true, true);
	y2milestone("User selected packages: %1", ret_map["packages"]:[]);

        ret_map["base"] = selbase[0]:"";
	y2milestone("selected base: %1", selbase[0]:"");

	if (size(selbase) > 1)
	{
	    // add the other base patterns to addons
	    list other_base = remove(selbase, 0);

	    seladd = merge(other_base, seladd);
	}

        ret_map["addons"] = seladd;
	y2milestone("selected addons: %1", seladd);

	// remember taboo packages
	ret_map["taboo"] = Pkg::GetPackages(`taboo, true);
	y2milestone("taboo packages: %1", ret_map["taboo"]:[]);

	// patterns are used in the product
        ret_map["type"] = `patterns;

	ret_map["ui"] = ret;

        Wizard::CloseDialog();
        return ret_map;
    }

    /**
     * Display package selection dialog with preselected packages.
     * @param base_pattern base pattern to install, can be empty ("") if there is no base pattern
     * @param patterns list of patterns to install
     * @param packages list of packages to install
     * @param taboo list of packages marked as taboo
     * @param mode UI mode selection, use `packages for detailed package selection or `patterns for pattern selection.
     * @return map<string,any>
     */
    map<string,any> runPackageSelector(string base_pattern, list<string> patterns, list<string> packages, list<string> taboo, symbol mode)

    {
        return runPackageSelectorVersions (base_pattern, patterns, packages, $[], taboo, mode);
    }

    /**
     * Select packages
     * @return symbol
     */
    define symbol packageSelector()
    {
	map<string,any> result = $[];

	do
	{
	    string base_pattern = ProductCreator::Config["base"]:"";
	    list<string> patterns = ProductCreator::Config["addons"]:[];
	    list<string> packages = ProductCreator::Config["packages"]:[];
	    list<string> taboo = ProductCreator::Config["taboo"]:[];

            map<string,string> versions = listmap (map p, ProductCreator::Config["package_versions"]:[], {
                return $[ p["name"]:"" : p["version"]:"" ];
            });

	    result = runPackageSelectorVersions(base_pattern, patterns, packages, versions, taboo, `patterns);

	    y2debug("Package selector result: %1", result);

	    ProductCreator::Config["base"] = result["base"]:"";
	    ProductCreator::Config["addons"] = result["addons"]:[];
	    ProductCreator::Config["packages"] = result["packages"]:[];
	    ProductCreator::Config["taboo"] = result["taboo"]:[];
	    ProductCreator::Config["type"] = result["type"]:`patterns;
	}
	while(result["ui"]:`next == `cancel && !ProductCreator::ReallyAbort());

	// the package selector returns `cancel when pressing [Abort]
	if (result["ui"]:`next == `cancel)
	{
	    return `abort;
	}

	return result["ui"]:`next;
    }


    term GpgDialogContent()
    {
	return `MarginBox(2, 1,
	    `VBox (
		`Left("sign_checkbox"),
		`VSpacing(0.5),
		"select_private_key",
		`VSpacing(1),
		"create_new_key"
	    )
	);
    };

    void refreshSigningDialog(boolean sign)
    {
	UI::ChangeWidget(`id("create_new_key"), `Enabled, sign);
	UI::ChangeWidget(`id(`gpg_priv_table), `Enabled, sign);
	UI::ChangeWidget(`id(`gpg_priv_label), `Enabled, sign);
    }

    symbol SignContent(string key, map event)
    {
	y2debug("SignContent: %1, %2", key, event);

	if (key == "sign_checkbox")
	{
	    // refresh table and pushbutton state
	    boolean sign = (boolean)UI::QueryWidget(`id("sign_checkbox"), `Value);
	    refreshSigningDialog(sign);
	}

	return nil;
    }

    void signCheckboxInit(string key)
    {
	if (key == "sign_checkbox")
	{
	    boolean sign = false;

	    if (ProductCreator::Config["gpg_key"]:"" != "")
	    {
		sign = true;
	    }

	    UI::ChangeWidget(`id("sign_checkbox"), `Value, sign);
	    refreshSigningDialog(sign);
	}
    }

    map sign_checkbox_widget()
    {
	return $[
	"sign_checkbox" :
	    $[
		"widget" : `checkbox,
		"opt"	 : [ `notify ],
		"init"	 : signCheckboxInit,
		"label"  : _("&Digitally Sign the Product on the Medium"),
		"handle_events" : ["sign_checkbox"],
		"handle" : SignContent,
		// TODO: validate the dialog (is a key selected if the checkbox is selected?
		// "validate_help" : _("Select a gpg key in the table. Create...")
		"help" : _("<p><big><b>Sign</b></big><br>
To make it possible for users to verify your product, sign it with a GPG key. 
This key is checked when the product is added as a repository.</p>")
		// part of the help text (signing dialog), the URL can be modified to the translated language
		// (if the page exists in that language, you have to check that!)
		+ _("<P>If the product is not signed, Yast automatically adds the option 'Insecure:\n1' to the linuxrc configuration file, otherwise linuxrc would deny loading an unsigned installation system at boot. See http://en.opensuse.org/Linuxrc for more information.</P>")
	    ]
	];
    }


    symbol gpgKeyDialog()
    {
	string caption = _("Signing the Product on the Medium");

	if (ProductCreator::Config["gpg_key"]:"" != "")
	{
	    // preselect the key
	    GPGWidgets::SetSelectedPrivateKey(ProductCreator::Config["gpg_key"]:"");
	}

	symbol ret = nil;

	do
	{
	    ret = CWM::ShowAndRun ($[
		"widget_names" : ["sign_checkbox", "select_private_key", "create_new_key"],
		"widget_descr" : union(GPGWidgets::Widgets(), sign_checkbox_widget()),
		"contents" :  GpgDialogContent(),
		"caption" : caption,
		"back_button" : Label::BackButton (),
		"next_button" : Label::NextButton (),
		"fallback_functions" : $[]
	    ]);
	}
	while(ret == `abort && !ProductCreator::ReallyAbort());

	boolean sign = (boolean)UI::QueryWidget(`id("sign_checkbox"), `Value);
	y2milestone("Sign the medium: %1", sign);

	string gpg_key = (sign) ? GPGWidgets::SelectedPrivateKey() : "";
	y2milestone("GPG signing key: %1", gpg_key);

	// remember the key
	ProductCreator::Config["gpg_key"] = gpg_key;

	return ret;
    }

    /**
     * Configuration Summary
     * @return void
     */
    define symbol ConfigSummary() ``{
        import "Summary";

        Wizard::CreateDialog();
        Wizard::SetDesktopTitleAndIcon("product-creator");
        string caption = _("Configuration Summary");
        Wizard::SetContents( caption,
                `Empty(),
                "",
                false,
                false);

	ProductCreator::CommitConfig();


        string summary = "";
        // summary caption
        summary = Summary::AddHeader(summary, _("Package Source") );
        summary = Summary::OpenList(summary);
        foreach(string s, ProductCreator::Config["sources"]:[], ``{
                summary = Summary::AddListItem(summary, s);
                });
        summary = Summary::CloseList(summary);
        // summary caption
        summary = Summary::AddHeader(summary, _("Packages") );

        // summary line
        summary = Summary::AddLine(summary, sformat(_("Selected %1 packages"),
                    size(Pkg::GetPackages(`selected, true))));

	string arch = ProductCreator::Config["arch"]:"";
	// display the architecture in the summary if it has been changed
	if (arch != nil && arch != "" && arch != Arch::architecture())
	{
	    summary = Summary::AddHeader(summary, _("Architecture") );

	    // summary line, %1 is e.g. i386, x86_64, ppc...
	    summary = Summary::AddLine(summary, sformat(_("Target architecture: %1"), arch));
	}

        // summary caption
        summary = Summary::AddHeader(summary,_("Output Directory"));

	if (ProductCreator::Config["result"]:"tree" == "iso")
	{
	    summary = Summary::AddLine (summary,
		// summary line (%1/%2 is file path)
		sformat (_("Creating ISO image %1/%2"),
		    ProductCreator::Config["iso-directory"]:"",
		    ProductCreator::Config["isofile"]:"")
	    );
	}
	else
	{
	    summary = Summary::AddLine (summary,
		// summary line (%1/%2 is file path)
		sformat(_("Creating directory tree in <b> %1/%2 </b>"),
                    ProductCreator::Config["iso-directory"]:"",
                    ProductCreator::Config["name"]:"")
	    );
	}


	// header in the summary dialog
	summary = Summary::AddHeader(summary, _("Signing"));
	string gpgkey = ProductCreator::Config["gpg_key"]:"";

	if (gpgkey != "")
	{
	    list<map> privatekeys = GPG::PrivateKeys();
	    string uid = "";

	    foreach(map key, privatekeys,
		{
		    if (key["id"]:"" == gpgkey)
		    {
			uid = mergestring(key["uid"]:[], ", ");
		    }
		}
	    );

	    if (uid != "")
	    {
		uid = sformat(" (%1)", uid);
	    }

	    // summary text - %1 is GPG key ID (e.g. ABCDEF01), %2 is GPG key user ID (or empty if not defined)
	    summary = Summary::AddLine(summary, sformat(_("Digitally sign the medium with GPG key <b>%1</b>%2"), gpgkey, String::EscapeTags(uid)));
	}
	else
	{
	    // summary text
	    summary = Summary::AddLine(summary, _("The medium will not be digitally signed"));
	}

        term contents =
            `RichText(summary);

        string help_text = _("<p>Verify the data in the summary then press Next to continue.
</p>
");

        Wizard::SetContentsButtons ( caption,
                contents,
                help_text,
                Label::BackButton (),
                Label::FinishButton ());
        any ret = nil;
        repeat
        {
            ret = UI::UserInput();

	    if (ret == `abort && !ProductCreator::ReallyAbort())
	    {
		// abort canceled
		ret = `dummy;
	    }
        }  until (ret == `next || ret == `back || ret == `abort);
        Wizard::CloseDialog();

        return (symbol)ret;
    }



    /* EOF */
}
