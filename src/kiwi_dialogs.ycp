/**
 * File:	include/product-creator/kiwi.ycp
 * Package:	Configuration of product-creator
 * Summary:	Dialogs for kiwi configuration
 * Authors:	Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 */
{
  textdomain "product-creator";

  import "Arch";
  import "CWM";
  import "CWMTab";
  import "Directory";
  import "FileUtils";
  import "Keyboard";
  import "Kiwi";
  import "Label";
  import "Message";
  import "Package";
  import "PackageLock";
  import "PackageSystem";
  import "Popup";
  import "ProductCreator";
  import "SourceDialogs";
  import "SourceManager";
  import "String";
  import "Summary";
  import "URL";
  import "Wizard";

  include "product-creator/dialogs.ycp";
  include "product-creator/routines.ycp";

  // map of current image configuration
  map<string,any> KiwiConfig	= $[];

  // what are we configuring now ("iso"/"xen"/...)
  string kiwi_task	= "";

  string content_key	= Kiwi::content_key;

  map section_type_label	= $[
    "image"	: _("Packages for Image"),
    "bootstrap"	: _("Bootstrap"),
    "xen"	: _("Xen Specific Packages")
  ];

  // map indexes of packages sets to their names
  // (package set is indexed in the sets list)
  map<integer,string> index2package_set	= $[];

  map<string,integer> package_set2index	= $[];

  // read available the images under /usr/share/kiwi/image/ directory
  list<term> GetAvailableImages (string subdir) {

    list<term> ret	= [];
    string dir		= "/usr/share/kiwi/image/";
    map out = (map) SCR::Execute (.target.bash_output,
	sformat ("ls %1/%2", dir, subdir));
    if (out["exit"]:0 != 0)
	return ret;
    foreach (string file, splitstring (out["stdout"]:"", "\n"), {
	if (file != "" && FileUtils::IsDirectory (sformat ("%1/%2/%3", dir, subdir, file)))
	{
	    ret	= add (ret, `item (`id(file), file, file == KiwiConfig[subdir]:""));
	}
    });
    return ret;
  }

  /*****************************************************************************
   * widget handlers
   ****************************************************************************/

  define void InitCompressionCombo (string id) {

    string current_method	= "none";
    foreach (map typemap, (list<map>)KiwiConfig["preferences",0,"type"]:[], {
	if (typemap["image"]:"" == kiwi_task)
	{
	    current_method	= typemap["flags"]:current_method;
	}
    });
    map<string,string> methods	= $[
	"unified"		: "unified",
	"compressed"		: "compressed",
	"clic"                  : "clic",
	// combo box label
	"none"			: _("None")
    ];
    list items	= maplist (string method, string label, methods, {
	return `item (`id (method), label, method == current_method);
    });
    UI::ChangeWidget (`id (id), `Items, items);
  }

  define void StoreCompressionCombo (string key, map event) {

    string selected	= (string) UI::QueryWidget (`id (key), `Value);
    KiwiConfig["preferences",0,"type"]	= maplist (map typemap,
	(list<map>)KiwiConfig["preferences",0,"type"]:[],
    {
	if (typemap["image"]:"" == kiwi_task)
	{
	    if (selected == "none")
	    {
		if (haskey (typemap, "flags"))
		    typemap	= remove (typemap, "flags");
	    }
	    else
		typemap["flags"]	= selected;
	}
	return typemap;
    });
  }

  define symbol HandleCompressionCombo (string key, map event) {
    if (event["ID"]:nil == `next) StoreCompressionCombo (key, event);
    return nil;
  }

  void InitDiskPassword (string id) {

    string disk_password	= "";
    foreach (map typemap, (list<map>)KiwiConfig["preferences",0,"type"]:[], {
	if (typemap["image"]:"" == kiwi_task)
	{
	    disk_password	= typemap["luks"]:disk_password;
	}
    });
    UI::ChangeWidget (`id (id), `Value, disk_password);
    UI::ChangeWidget (`id (id), `Enabled, disk_password != "");
    UI::ChangeWidget (`id ("encrypt_disk"), `Value, disk_password != "");
  }

  void StoreDiskPassword (string key, map event) {

    string disk_password = (string) UI::QueryWidget (`id (key), `Value);
    if (UI::QueryWidget (`id ("encrypt_disk"), `Value) == false)
	disk_password	= "";

    KiwiConfig["preferences",0,"type"]	= maplist (map typemap,
	(list<map>)KiwiConfig["preferences",0,"type"]:[],
    {
	if (typemap["image"]:"" == kiwi_task)
	{
	    if (disk_password == "")
	    {
		if (haskey (typemap, "luks"))
		    typemap	= remove (typemap, "luks");
	    }
	    else
		typemap["luks"]	= disk_password;
	}
	return typemap;
    });
  }

  symbol HandleDiskPassword (string key, map event) {
    if (event["ID"]:nil == `next) StoreDiskPassword (key, event);
    return nil;
  }

  symbol HandleEncryptDisk (string key, map event) {
    boolean value = (boolean) UI::QueryWidget (`id (key), `Value);
    UI::ChangeWidget (`id ("disk_password"), `Enabled, value);
    return nil;
  }

  /**
   * Initialize the widget with ignored packages
   */
  define void InitSWIgnore (string id) {
    string sw_selection	= KiwiConfig["sw_selection"]:"image";
    string ignore_key	= sw_selection == "image" ? "ignore" : (sw_selection + "_ignore");
    UI::ChangeWidget (`id (id), `Value, mergestring (KiwiConfig[ignore_key]:[], "\n"));
  }

  define void StoreSWIgnore (string key, map event) {
    string sw_selection	= KiwiConfig["sw_selection"]:"image";
    string ignore_key	= sw_selection == "image" ? "ignore" : (sw_selection + "_ignore");
    KiwiConfig[ignore_key]	= filter (string p,
	splitstring ((string) UI::QueryWidget(`id(key), `Value), "\n"), ``(p != ""));
  }

  define symbol HandleSWIgnore (string key, map event) {
    if (event["ID"]:nil == `next) StoreSWIgnore (key, event);
    return nil;
  }

  /**
   * Initialize the widget with packages intended for deletion
   */
  define void InitSWDelete (string id) {

    list<string> to_delete	= [];
    foreach (map pmap, KiwiConfig["packages"]:[], {
	string type	= pmap["type"]:"";
	if (type == "delete")
	{
	    to_delete	= maplist (map pacmap, pmap["package"]:[], ``(
		pacmap["name"]:"")
	    );
	}
    });
    UI::ChangeWidget (`id (id), `Value, mergestring (to_delete, "\n"));
  }

  define void StoreSWDelete (string key, map event) {

    list<string> to_delete	= filter (string p, splitstring (
	(string) UI::QueryWidget (`id(key), `Value), "\n"), ``(p != "")
    );
    integer index	= 0;
    integer del_index	= -1;
    foreach (map pmap, KiwiConfig["packages"]:[], {
	if (pmap["type"]:"" == "delete")
	{
	    del_index	= index;
	    break;
	}
	index	= index + 1;
    });

    map sw_contents	= KiwiConfig["packages",del_index]:$[];
    if (del_index == -1)
    {
	sw_contents	= $[ "type" : "delete" ];
	del_index	= size (KiwiConfig["packages"]:[]);
	KiwiConfig["packages"] = add (KiwiConfig["packages"]:[], $[]);
    }
    sw_contents["package"]	= maplist (string name, to_delete,
	``($[ "name" : name])
    );
    KiwiConfig["packages",del_index]	= sw_contents;
  }

  define symbol HandleSWDelete (string key, map event) {
    if (event["ID"]:nil == `next) StoreSWDelete (key, event);
    return nil;
  }

  /**
   * Initialize the contents of richtext with selected software
   */
  define void InitSWRichText (string id) {

    integer package_set	= KiwiConfig["package_set"]:0;
    string rt	= "";

    list packages	= KiwiConfig["packages"]:[];
    string pat	= "";
    string pac	= "";
    string ign	= "";

    if (index2package_set[package_set]:"" == "bootinclude")
    {
	package_set	= package_set2index["image"]:0;

	if (size (packages[package_set,"package"]:[]) > 0)
	// richtext header
	    pac	= Summary::AddHeader ("", _("Packages"));
	foreach (map pacmap, packages[package_set,"package"]:[], {
	    if (pacmap["bootinclude"]:"" == "true")
		pac	= Summary::AddListItem (pac, pacmap["name"]:"");
	});
	UI::ChangeWidget (`id (id), `Value, pat + pac + ign);
	return;
    }

    if (size (packages[package_set,"opensusePattern"]:[]) > 0)
	// richtext header
	pat     = Summary::AddHeader ("", _("Patterns"));
    foreach (map patmap, packages[package_set,"opensusePattern"]:[], {
	pat	= Summary::AddListItem (pat, patmap["name"]:"");
    });
    if (size (packages[package_set,"package"]:[]) > 0)
	// richtext header
	pac	= Summary::AddHeader ("", _("Packages"));
    foreach (map pacmap, packages[package_set,"package"]:[], {
	if (pacmap["bootinclude"]:"" != "true")
	    pac	= Summary::AddListItem (pac, pacmap["name"]:"");
    });
    if (size (packages[package_set,"ignore"]:[]) > 0)
	ign	= Summary::AddHeader ("",
	    deletechars (_("&Ignored Software"), "&"));
    foreach (map pacmap, packages[package_set,"ignore"]:[], {
	ign	= Summary::AddListItem (ign, pacmap["name"]:"");
    });
    UI::ChangeWidget (`id (id), `Value, pat + pac + ign);
  }


  /**
   * open package selector with given set of packages, return modified set
   * or nil on cancel
   */
  define map modifyPackageSelection (map sw_contents) {

	integer mbytes	= (integer) UI::QueryWidget (`id ("size"), `Value);
	if (UI::QueryWidget (`id ("sizeunit"), `Value) == "G")
	    mbytes	= mbytes * 1024;
	ProductCreator::max_size_mb	= mbytes;
	// no size check for "additive" (bnc#512358)
	if (UI::QueryWidget (`id ("additive"), `Value) == true)
	    ProductCreator::max_size_mb	= 999 * 1024 * 1024;

	map<string,any> ret_map	= runPackageSelector ("",
	    maplist (map pat, sw_contents["opensusePattern"]:[],
		``(pat["name"]:"")),
	    maplist (map pat, sw_contents["package"]:[],
		``(pat["name"]:"")),
	    maplist (map pat, sw_contents["ignore"]:[],
		``(pat["name"]:"")),
	    `packages
	);
	if (ret_map["ui"]:nil == `cancel || ret_map["ui"]:nil == `failed)
	    return nil;
	sw_contents["opensusePattern"]	= maplist (string name,
	    ret_map["addons"]:[], ``($[ "name" : name]));
	sw_contents["package"]	= maplist (string name,
	    ret_map["packages"]:[], ``($[ "name" : name]));
	sw_contents["ignore"]	= maplist (string name,
	    ret_map["taboo"]:[], ``($[ "name" : name]));

    return sw_contents;
  }

  /**
   * Popup for modifying the list of 'bootinclude' packages
   */
  define list modifyBootIncludePackages (list packages) {

    UI::OpenDialog (`opt(`decorated), `HBox (`HSpacing (0.5), `VSpacing (20), `VBox (
	`HSpacing (70),
	`VSpacing (0.5),
	`MultiLineEdit (`id (`bootinclude), _("Packages to be included in Boot Image"),
	    mergestring ((list<string>) maplist (map p, (list<map>) packages, ``(p["name"]:"")), "\n")
	),
	`ButtonBox (
	    `PushButton (`id(`ok),`opt(`default,`key_F10),Label::OKButton()),
	    `PushButton (`id(`cancel),`opt (`key_F9), Label::CancelButton())
	)
    ), `HSpacing (0.5)));
    any ret	= UI::UserInput ();
    string value= (string)UI::QueryWidget (`id (`bootinclude), `Value);
    list retlist= maplist (string name, filter (string p, splitstring (value, "\n"), ``(p != "")), {
	return $[
	    "name"		: name,
	    "bootinclude"	: "true"
	];
    });

    UI::CloseDialog ();
    if (ret == `cancel)
	return nil;
    return retlist;
  }

  /**
   * check the conflicts between packages selected and marked for deletion (fate#305254)
   * @param packages_before map of packages already selected before entering package selector
   */
  define boolean CheckForDeletedPackages (map packages_before) {

    y2milestone ("checking list of selected packages...");
    StoreSWDelete ("delete_sw", $[]);
    map to_delete	= $[];
    foreach (map pmap, KiwiConfig["packages"]:[], {
	string type	= pmap["type"]:"";
	if (type == "delete")
	{
	    to_delete	= listmap (map pacmap, pmap["package"]:[], ``(
		$[ pacmap["name"]:"" : true ])
	    );
	}
    });
    boolean conflicting	= false;
    if (size (to_delete) > 0)
    {
	foreach (map package, Pkg::ResolvableProperties("", `package, ""), {
	    if (conflicting)
		break;
	    string name		= package["name"]:"";
            // only look at packages selected in last package selector run
	    if (package["status"]:nil == `selected && !haskey (packages_before, name))
	    {
		symbol transact_by	= package["transact_by"]:`none;
		if (transact_by == `solver || transact_by == `user || transact_by == `app_high)
		{
		    if (haskey (to_delete, name))
		    {
			y2milestone ("packege %1 selected by %2 is present in the delete list",
			    name, transact_by);
			conflicting	= true;
		    }
		}
	    }
	});
    }
    return conflicting;
  }

  /**
   * Handler for software selection
   */
  define symbol HandleSWSelection (string key, map event) {

    if (event["ID"]:nil == key)
    {
	integer package_set	= KiwiConfig["package_set"]:0;
	boolean bootinclude	= false;
	if (index2package_set[package_set]:"" == "bootinclude")
	{
	    package_set	= package_set2index["image"]:0;
	    bootinclude		= true;
	}

	map sw_contents		= KiwiConfig["packages",package_set]:$[];
        map packages_before     = $[];

	// separate bootinclude packages from normal ones
	list bi_packages	= [];
	sw_contents["package"]	= filter (map p, sw_contents["package"]:[], {
            packages_before[p["name"]:""]       =  true;
	    if (p["bootinclude"]:"" == "true")
		bi_packages	= add (bi_packages, p);
	    return p["bootinclude"]:"" != "true";
	});

	if (bootinclude)
	{
	    bi_packages	= modifyBootIncludePackages (bi_packages);
	}
	else
	{
            boolean again       = true;
            while (again)
            {
	      sw_contents	= modifyPackageSelection (sw_contents);
              again             = CheckForDeletedPackages (packages_before);
              if (again && Popup::YesNo (_("Some of the packages that are selected for installation
are also included in the list for deletion.
Continue anyway?")))
              {
                  again         = false;
              }
            }
	}

	if (sw_contents != nil && bi_packages != nil)
	{
		sw_contents["package"]  = union (sw_contents["package"]:[], bi_packages);
		KiwiConfig["packages",package_set]	= sw_contents;
	}
	InitSWRichText ("rt_sw");
    }
    return nil;
  }

  /**
   * initialize the combo box with package selection groups
   */
  define void InitSWSelectionCombo (string id) {
    integer package_set	= KiwiConfig["package_set"]:0;
    list items	= [];
    integer i	= 0;
    foreach (map pmap, KiwiConfig["packages"]:[], {
	string type	= pmap["type"]:"";
	// combo box label
	string label	= _("Packages for Image");
	if (type == "delete")
	{
	    // combo box label
	    label       = _("Packages to Delete");
	    i		= i + 1; // index to list must be increased
	    return; // delete is handled by different widgets
	}
	index2package_set[i]	= type;
	package_set2index[type]	= i;
	if (type == "bootstrap")
	    // combo box label
	    label	= _("Bootstrap");
	else if (type == "xen")
	    // combo box label
	    label	= _("Xen Specific Packages");
	else if (type == "testsuite")
	    // combo box label
	    label       = _("Testing");
	else if (type != "image")
	    label       = type;
	if (pmap["profiles"]:"" != "")
	    // combo box label, %1 is profile name
	    label = sformat(_("Image, profile %1"),pmap["profiles"]:"");
	items	= add (items, `item (`id (i), label, package_set == i));
	i	= i + 1;
    });
    // combo box label
    items	= add (items, `item (`id (i), _("Include in Boot Image"), package_set == i));
    index2package_set[i]	= "bootinclude";
    UI::ChangeWidget (`id (id), `Items, items);
  }

  define void StoreSWSelectionCombo (string key, map event) {
      KiwiConfig["package_set"]	= (integer) UI::QueryWidget(`id(key), `Value);
  }

  /**
   * handler for combo box with package sets items
   */
  define symbol HandleSWSelectionCombo (string key, map event) {
    any id	= event["ID"]:nil;
    // store the value on exiting
    if (id == `next) StoreSWSelectionCombo (key, event);
    else if (event["ID"]:nil == key)
    {
	integer selected	= (integer) UI::QueryWidget(`id(key), `Value);
	if (selected != KiwiConfig["package_set"]:-1)
	{
	    KiwiConfig["package_set"]	= selected;
	    StoreSWSelectionCombo (key, event);
	    InitSWRichText ("rt_sw");
	}
    }
    return nil;
  }


  /**
   * initialize the value of combo box with boot items
   */
  define void InitBootCombo (string id) {
    UI::ChangeWidget (`id (id), `Items, GetAvailableImages (id));
  }

  /**
   * store the value of current boot image
   */
  define void StoreBootCombo (string key, map event) {
      KiwiConfig[key]	= (string) UI::QueryWidget(`id(key), `Value);
  }
  /**
   * handler for combo box with boot items
   */
  define symbol HandleBootCombo (string key, map event) {
    // store the value on exiting
    if (event["ID"]:nil == `next) StoreBootCombo (key, event);
    return nil;
  }

  /**
   * initialize the value of version
   */
  define void InitVersion (string id) {
    UI::ChangeWidget (`id (id), `Value,
	get_preferences (KiwiConfig, "version", "1.0.0")
    );
  }

  /**
   * store the value of current version
   */
  define void StoreVersion (string key, map event) {
    KiwiConfig["preferences",0,"version"]	= [ $[
	content_key :  sformat ("%1", UI::QueryWidget(`id(key), `Value))
    ]];
  }

  /**
   * handler for version
   */
  define symbol HandleVersion (string key, map event) {
    // store the value on exiting
    if (event["ID"]:nil == `next) StoreVersion (key, event);
    return nil;
  }

  /**
   * initialize the values of "size", "sizeunit" and "additive" widgets
   */
  define void InitSize (string id) {

    map size_map    = get_current_size_map (KiwiConfig, kiwi_task);

    integer siz	= tointeger (size_map[Kiwi::content_key]:"0");
    if (siz == nil) siz	= 0;
    UI::ChangeWidget (`id ("size"), `Value, siz);
    UI::ChangeWidget (`id ("additive"), `Value, size_map["additive"]:"" == "true");
    UI::ChangeWidget (`id ("sizeunit"), `Items, maplist (string u, [ "M", "G" ], ``(
	`item (`id (u), u + "B", size_map["unit"]:"M" == u))
    ));
  }

  /**
   * store the values of "size", "sizeunit" and "additive" widgets
   */
  define void StoreSize (string key, map event) {

    KiwiConfig["preferences",0,"type"]	= maplist (map typemap,
	(list<map>)KiwiConfig["preferences",0,"type"]:[],
    {
	if (typemap["image"]:"" == kiwi_task)
	{
	    typemap["size"]	=	[ $[
		content_key	: sformat ("%1", UI::QueryWidget(`id(key), `Value)),
		"unit"		: UI::QueryWidget (`id ("sizeunit"), `Value),
		"additive"	: ((boolean) UI::QueryWidget (`id ("additive"), `Value)) ? "true" : "false",
	    ] ];
	}
	return typemap;
    });

  }

  /**
   * handler for size widget: store value on exit/save
   */
  define symbol HandleSize (string key, map event) {
    // store the value on exiting
    if (event["ID"]:nil == `next) StoreSize (key, event);
    return nil;
  }

  /**
   * initialize the product label
   */
  define void InitLabel (string id) {
    UI::ChangeWidget (`id ("name"), `Value, KiwiConfig["name"]:"");
  }


  /**
   * universal widget: initialize the string value of widget @param
   */
  define void InitGeneric (string id) {
    UI::ChangeWidget (`id (id), `Value, KiwiConfig[id]:"");
  }

  /**
   * store the string value of given widget
   */
  define void StoreGeneric (string key, map event) {
      KiwiConfig[key]	= UI::QueryWidget (`id(key), `Value);
  }

  /**
   * handler for general string-value widgets: store their value on exit/save
   */
  define symbol HandleGeneric (string key, map event) {
    // store the value on exiting
    if (event["ID"]:nil == `next) StoreGeneric (key, event);
    return nil;
  }

  /**
   * initialize the string value of "description" related widget
   */
  define void InitDescription (string id) {
    UI::ChangeWidget (`id (id), `Value,
	KiwiConfig["description",0,id,0,content_key]:""
    );
  }

  /**
   * store the string value of "description" related given widget
   */
  define void StoreDescription (string key, map event) {
    KiwiConfig["description",0,key]	= [ $[
	content_key : UI::QueryWidget (`id(key), `Value)
    ]];
  }

  /**
   * handler for string-value "description" related widgets: store on exit/save
   */
  define symbol HandleDescription (string key, map event) {
    // store the value on exiting
    if (event["ID"]:nil == `next) StoreDescription (key, event);
    return nil;
  }

  /**
   * initialize the list value of "locale" combo box
   */
  define void InitLocaleCombo (string id) {

    string lang	= KiwiConfig["preferences",0,id,0,content_key]:"";
    list items		= [
      `item (`id ("none"), "---", false)
    ];
    if (Kiwi::all_locales == $[])
    {
	map out = (map) SCR::Execute (.target.bash_output, "/usr/bin/locale -a");
	foreach (string line, splitstring (out["stdout"]:"", "\n"), {
	    string code = splitstring (line, ".@")[0]:line;
            if (code != "" && code != "C" && code != "POSIX")
	        Kiwi::all_locales[code] = 1;
	});
    }
    foreach (string code, integer i, Kiwi::all_locales, {
	items	= add (items, `item (`id (code), code, lang == code));
    });

    UI::ChangeWidget (`id (id), `Items, items);
  }

  /**
   * initialize the list value of "keytable" combo box
   */
  define void InitKeytableCombo (string id) {

    string kb = KiwiConfig["preferences",0,id,0,content_key]:"";

    list items		= [];
    boolean kb_present	= false;

    foreach (string name, string yast, Keyboard::keymap2yast (), {
	items	= add (items, `item (`id (name), name, kb == name));
	if (kb == name) kb_present = true;
    });
    if (!kb_present)
    {
	items       = add (items, `item (`id (kb), kb, true));
    }
    UI::ChangeWidget (`id (id), `Items, items);
  }

  /**
   * initialize the list value of "timezone" combo box
   */
  define void InitTimezoneCombo (string id) {

    string tz = KiwiConfig["preferences",0,id,0,content_key]:"";

    if (Kiwi::all_timezones == [])
    {
	map out = (map) SCR::Execute (.target.bash_output,
	    "grep -v '#' /usr/share/zoneinfo/zone.tab | cut -f 3 | sort", $["LANG":"C"]);
	Kiwi::all_timezones	= filter (string t, splitstring (out["stdout"]:"", "\n"), {
	    return t != "";
	});
    }

    list items		= maplist (string zone, Kiwi::all_timezones, {
	return `item (`id (zone), zone, tz == zone);
    });
    items		= prepend (items, `item (`id ("none"), "---"));

    UI::ChangeWidget (`id (id), `Items, items);
  }

  /**
   * initialize the string value of "preferences" related widget
   */
  define void InitPreferences (string id) {
    UI::ChangeWidget (`id (id), `Value,
	KiwiConfig["preferences",0,id,0,content_key]:""
    );
  }

  /**
   * store the string value of "preferences" related given widget
   */
  define void StorePreferences (string key, map event) {
    string val	= (string) UI::QueryWidget (`id(key), `Value);

    // split .UTF-8 endings from locale (bnc#675101)
    if (key == "locale")
    {
	list<string> split = splitstring (val, ".");
	val	= split[0]:val;
	UI::ChangeWidget (`id (key), `Value, val);
    }
    if ((val == "" || val == "none") && haskey (KiwiConfig["preferences",0]:$[], key))
    {
	KiwiConfig["preferences",0]	=
	    remove (KiwiConfig["preferences",0]:$[], key);
    }
    else if (val != "" && val != "none")
    {
	KiwiConfig["preferences",0,key]	= [ $[
	    content_key : UI::QueryWidget (`id(key), `Value)
	]];
    }
  }

  /**
   * handler for string-value "preferences" related widgets: store on exit/save
   */
  define symbol HandlePreferences (string key, map event) {
    // store the value on exiting
    if (event["ID"]:nil == `next) StorePreferences (key, event);
    return nil;
  }

  /**
   * initialize the table with users
   */
  define void InitUsersTable (string id) {

    list items	= [];
    foreach (map groupmap, (list<map>) KiwiConfig["users"]:[], {
	string group	= groupmap["group"]:"";
	string gid      = groupmap["id"]:"";
	foreach (map usermap, (list<map>) groupmap["user"]:[], {
	    items	= add (items,
		`item (
		    `id (usermap["name"]:""),
		    usermap["name"]:"",
		    usermap["realname"]:"",
		    usermap["id"]:"",
		    usermap["home"]:"",
		    group, gid
		)
	    );
	});
    });
    UI::ChangeWidget (`id ("table"), `Items, items);
    UI::ChangeWidget (`id ("edituser"), `Enabled, size (items) > 0);
    UI::ChangeWidget (`id ("deleteuser"), `Enabled, size (items) > 0);
  }

  /**
   * Handle changes in users table
   */
  define symbol HandleAddEditUser (string key, map event) {
    if (event["ID"]:nil != key &&
	(key != "userstable" || event["ID"]:nil != "table"))
	return nil;

    if (key == "userstable") key = "edituser";
    string current_user = (string) UI::QueryWidget (`id ("table"),`CurrentItem);
    map user_map	= $[];
    map group_map	= $[];
    if (key == "edituser")
    {
	foreach (map gmap, (list<map>) KiwiConfig["users"]:[], {
	    user_map	= find (map umap, (list<map>) gmap["user"]:[],
		``(current_user == umap["name"]:"")
	    );
	    if (user_map != $[] && user_map != nil)
	    {
		group_map	= gmap;
		break;
	    }
	});
    }
    // store original names
    string user		= user_map["name"]:"";
    string group	= group_map["group"]:"";
    UI::OpenDialog (`opt(`decorated), `HBox (`HSpacing (0.5), `VBox (
	`VSpacing (0.5),
	// popup label
	`Label (`id (`label), _("Add new user")),
	// text entry label
	`InputField (`id (`username), `opt (`hstretch), _("Login &Name")),
	// text entry label
	`InputField (`id ("realname"), `opt (`hstretch),_("&Full Name")),
	`Password (`id (`pw1), `opt (`hstretch), Label::Password(), ""),
	`Password (`id(`pw2), `opt (`hstretch), Label::ConfirmPassword(), ""),
	// text entry label
	`InputField (`id ("home"), `opt (`hstretch), _("&Home Directory")),
	// text entry label
	`InputField (`id ("id"), `opt (`hstretch), _("&UID")),
	`HBox (
	// text entry label
	`InputField (`id (`group), `opt (`hstretch), _("G&roup Name")),
	// text entry label
	`InputField (`id (`gid), `opt (`hstretch), _("&GID"))
	),
	`HBox (
	    `PushButton (`id(`ok),`opt(`key_F10), Label::OKButton()),
	    `PushButton (`id(`cancel),`opt(`key_F9), Label::CancelButton())
	),
	`VSpacing (0.5)), `HSpacing (0.5))
    );
    UI::ChangeWidget (`id ("id"), `ValidChars, String::CDigit ());
    UI::ChangeWidget (`id (`gid), `ValidChars, String::CDigit ());
    if (key == "edituser")
    {
	UI::ChangeWidget (`id (`username), `Value, current_user);
	UI::ChangeWidget (`id ("realname"), `Value, user_map["realname"]:"");
	UI::ChangeWidget (`id ("home"), `Value, user_map["home"]:"");
	UI::ChangeWidget (`id ("id"), `Value, user_map["id"]:"");
	UI::ChangeWidget (`id (`gid), `Value, group_map["id"]:"");
	UI::ChangeWidget (`id (`group), `Value, group_map["group"]:"");
	if (user_map["pwd"]:"" != "")
	{
	    UI::ChangeWidget (`id (`pw1), `Value, user_map["pwd"]:"");
	    UI::ChangeWidget (`id (`pw2), `Value, user_map["pwd"]:"");
	}
	// popup label
	UI::ChangeWidget (`id (`label), `Value, _("Edit User"));
    }
    any ret	= nil;
    repeat
    {
	ret	= UI::UserInput ();
	if (ret == `ok)
	{
	    string username = (string) UI::QueryWidget (`id (`username),`Value);
	    string pwd	= (string) UI::QueryWidget (`id(`pw1), `Value);
	    string new_group = (string) UI::QueryWidget (`id (`group),`Value);
	    string gid = (string) UI::QueryWidget (`id (`gid),`Value);
	    if (username == "")
	    {
		// popup message
		Report::Error (_("Enter the user name."));
		ret     = `notnext;
		continue;
	    }
	    if (pwd != UI::QueryWidget (`id(`pw2), `Value))
	    {
		// popup message
		Report::Error (_("The passwords do not match.
Try again."));
		ret     = `notnext;
		continue;
	    }
	    // ok, now update the structures
	    user_map	= $[
		"pwd"		: pwd,
		"encrypted"	: user_map["encrypted"]:false && pwd == user_map["pwd"]:"",
		"name"		: username,
	    ];
	    foreach (string key, ["home", "realname", "id"], {
		if (UI::QueryWidget (`id (key), `Value) != "")
		    user_map[key]	= UI::QueryWidget (`id(key), `Value);
	    });

	    if (new_group == "")
		new_group	= (username == "root") ? "root" : "users";

	    boolean group_modified	= false;
	    KiwiConfig["users"]	= maplist (map gmap,
		(list<map>) KiwiConfig["users"]:[],
	    {
		// the group is already defined
		if (gmap["group"]:"" == new_group)
		{
		    if (gid != "")
			gmap["id"]	= gid;
		    boolean user_modified	= false;
		    gmap["user"]	= maplist (
			map umap, (list<map>) gmap["user"]:[],
		    {
			if (umap["name"]:nil == user ||
			    umap["name"]:nil == username)
			{
			    umap	= user_map;
			    user_modified	= true;
			}
			return umap;
		    });
		    if (!user_modified)
			gmap["user"]	= add (gmap["user"]:[], user_map);
		    group_modified	= true;
		}
		// remove user from original group (= group was 'renamed')
		else if (gmap["group"]:"" == group)
		{
		    gmap["user"]	= filter (
			map umap, (list<map>) gmap["user"]:[],
		    {
			return (umap["name"]:nil != user);
		    });
		}
		return gmap;
	    });
	    if (!group_modified)
	    {
		if (KiwiConfig["users"]:[] == [])
		    KiwiConfig["users"]	= [];
		group_map	= $[ "group": new_group, "user" : [ user_map ]];
		if (gid != "")
		    group_map["id"]	= gid;
		KiwiConfig["users"] = add (KiwiConfig["users"]:[], group_map);
	    }
	    // remove empty groups
	    KiwiConfig["users"]	= filter (map gmap,
		(list<map>) KiwiConfig["users"]:[], ``(gmap["user"]:[] != []));
	}
    } until (ret == `ok || ret == `cancel);

    UI::CloseDialog ();
    if (ret == `ok) InitUsersTable ("table");
    return nil;
  }

  /**
   * handle delete user button
   */
  define symbol HandleDeleteUser (string key, map event) {
    if (event["ID"]:nil != key)	return nil;

    string current_user = (string) UI::QueryWidget(`id ("table"), `CurrentItem);
    boolean is_empty	= false;
    KiwiConfig["users"]	= maplist (map gmap, (list<map>) KiwiConfig["users"]:[],
    {
	gmap["user"]	= filter (map umap, (list<map>) gmap["user"]:[],
	    ``(umap["name"]:"" != current_user)
	);
	if (size (gmap["user"]:[]) == 0)
	    is_empty	= true;
	return gmap;
    });
    if (is_empty)
    {
	// remove empty groups
	KiwiConfig["users"]	= filter (map gmap, (list<map>)
	    KiwiConfig["users"]:[], ``(gmap["user"]:[] != [])
	);
    }
    InitUsersTable ("table");
    return nil;
  }

  /**
   * initialize the table with root dir contents
   */
  define void InitRootDirTable (string id) {

    list items = maplist (string file, (list<string>) KiwiConfig["root_dir"]:[],
    {
	return `item (`id (file), file);
    });
    UI::ChangeWidget (`id ("roottable"), `Items, items);
    UI::ChangeWidget (`id ("root_dir_delete"), `Enabled, size (items) > 0);
  }

  // add new subdir to the 'root' directory
  define symbol HandleAddToRootDir (string key, map event) {

    if (event["ID"]:nil != key)	return nil;
    // popup for file selection dialog
    string dir	= UI::AskForExistingDirectory ("", _("Directory to Import"));
    if (dir!= nil)
    {
	KiwiConfig["root_dir"]	= union (KiwiConfig["root_dir"]:[], [dir]);
	InitRootDirTable ("roottable");
    }
    return nil;
  }

  // delete subdir from the 'root' directory
  define symbol HandleDeleteFromRootDir (string key, map event) {
    if (event["ID"]:nil != key)	return nil;
    string current	= (string) UI::QueryWidget (`id ("roottable"), `Value);
    KiwiConfig["root_dir"]	=
	filter (string f, KiwiConfig["root_dir"]:[], ``(f != current));
    InitRootDirTable ("roottable");
    return nil;
  }

  /**
   * initialize the table with config dir contents
   */
  define void InitConfigDirTable (string id) {

    list items = maplist (string file,(list<string>)KiwiConfig["config_dir"]:[],
    {
	return `item (`id (file), file);
    });
    UI::ChangeWidget (`id ("configtable"), `Items, items);
    UI::ChangeWidget (`id ("config_dir_delete"), `Enabled, size (items) > 0);
  }

  // add new subdir to the 'config' directory
  define symbol HandleAddToConfigDir (string key, map event) {

    if (event["ID"]:nil != key)	return nil;
    // popup for file selection dialog
    string dir	= UI::AskForExistingFile ("", "", _("Script to Import"));
    if (dir!= nil)
    {
	KiwiConfig["config_dir"] = union (KiwiConfig["config_dir"]:[], [dir]);
	InitConfigDirTable ("configtable");
    }
    return nil;
  }

  // delete subdir from the 'config' directory
  define symbol HandleDeleteFromConfigDir (string key, map event) {
    if (event["ID"]:nil != key)	return nil;
    string current	= (string) UI::QueryWidget (`id ("configtable"), `Value);
    KiwiConfig["config_dir"]	= filter (string f, KiwiConfig["config_dir"]:[], ``(f != current));
    InitConfigDirTable ("configtable");
    return nil;
  }

  /**
   * universal handler for directory browsing
   */
  string BrowseDirectoryHandler (string key, string label) {

    string current	= (string) UI::QueryWidget (`id (key), `Value);
    if (current == nil) current = "";
    string dir	= UI::AskForExistingDirectory (current, label);
    if (dir!= nil)
    {
	UI::ChangeWidget (`id (key), `Value, dir);
	StoreGeneric (key, $[]);
    }
    return dir;
  }

  /**
   * handler for 'root' directory browse
   */
  symbol HandleBrowseRootDirectory (string key, map event) {
    if (event["ID"]:nil != key) return nil;
    // popup for file selection dialog ('root' is a name, do not translate)
    BrowseDirectoryHandler ("root_dir", _("Path to root Directory"));
    return nil;
  }

  /**
   * handler for 'config' directory browse
   */
  symbol HandleBrowseConfigDirectory (string key, map event) {
    if (event["ID"]:nil != key) return nil;
    // popup for file selection dialog ('config' is a name, do not translate)
    BrowseDirectoryHandler ("config_dir", _("Path to config Directory"));
    return nil;
  }

  /**
   * universal handler for file browsing
   */
  string BrowseFileHandler (string key, string label) {

    string current	= (string) UI::QueryWidget (`id (key), `Value);
    if (current == nil) current = "";
    string file = UI::AskForExistingFile (current, "", label);
    if (file != nil && key != "config.sh")
    {
	UI::ChangeWidget (`id (key), `Value, file);
	StoreGeneric (key, $[]);
    }
    return file;
  }

  /**
   * Handler for browsing for images.sh file
   */
  symbol HandleBrowseImagesFile (string key, map event) {
    if (event["ID"]:nil != key) return nil;
    // popup for file selection dialog
    BrowseFileHandler ("images_path", _("Path to images.sh File"));
    return nil;
  }

  /**
   * Handler for browsing for autoyast profile
   */
  symbol HandleBrowseAutoYaSTFile (string key, map event) {
    if (event["ID"]:nil != key) return nil;
    // popup for file selection dialog
    BrowseFileHandler ("autoyast_path", _("Path to AutoYaST Profile"));
    return nil;
  }

  /**
   * Handler for importing config.sh file
   */
  symbol HandleImportConfigFile (string key, map event) {
    if (event["ID"]:nil != key) return nil;
    // popup for file selection dialog
    string file	= BrowseFileHandler ("config.sh", _("Path to config.sh File"));
    if (file != nil)
    {
	if (FileUtils::Exists (file))
	{
	    string configsh	= (string) SCR::Read (.target.string, file);
	    if (configsh != nil)
	    {
		UI::ChangeWidget (`id ("config.sh"), `Value, configsh);
		StoreGeneric ("config.sh", event);
	    }
	}
    }
    return nil;
  }

  /**
   * Handler for importing images.sh file
   * TODO same function as HandleImportConfigFile
   */
  symbol HandleImportImagesFile (string key, map event) {
    if (event["ID"]:nil != key) return nil;
    // popup for file selection dialog
    string file	= BrowseFileHandler ("images.sh", _("Path to images.sh File"));
    if (file != nil)
    {
	if (FileUtils::Exists (file))
	{
	    string imagessh	= (string) SCR::Read (.target.string, file);
	    if (imagessh != nil)
	    {
		UI::ChangeWidget (`id ("images.sh"), `Value, imagessh);
		StoreGeneric ("images.sh", event);
	    }
	}
    }
    return nil;
  }

  // generic popup
  define symbol NotImplementedHandler (string key, map event) {
    if (event["ID"]:nil == key)
    {
	Popup::Message (_("Feature not implemented yet."));
    }
    return nil;
  }

  /**
   * Check if selected packages are available (some of them may not after
   * deleting some repository)
   * return true if there was no conflict
   */
  define symbol CheckForAvailablePackages (boolean ignore_allowed) {

    list<map> packages_section	= KiwiConfig["packages"]:[];
    integer index		= 0;
    symbol ret			= `ok;
    foreach (map pmap, packages_section, {
	string type	= pmap["type"]:"";
	if (type != "delete")
	{
	    Popup::ShowFeedback (_("Checking packages availability..."), _("Please wait..."));
	    list<string> n_a	= [];

	    list bi_packages	= [];
	    map original_pmap	= pmap;
	    pmap["package"]	= filter (map p, pmap["package"]:[], {
		if (p["bootinclude"]:"" == "true")
		    bi_packages	= add (bi_packages, p);
		// do not check bootinclude packages
		else if (p["name"]:"" != "" && !Pkg::IsAvailable (p["name"]:""))
		    n_a	= add (n_a, p["name"]:"");
		return p["bootinclude"]:"" != "true";
	    });
	    Popup::ClearFeedback ();
	    if (size (n_a) > 0)
	    {
		ret			= `missing;
		string type_label	= section_type_label[type]:type;

		UI::OpenDialog (`opt (`decorated), `HBox (`VSpacing (25),
		    `VBox (
			`HSpacing (70),
			`Left(`Heading (_("Missing packages"))),
			`VSpacing(0.2),
			// popup text
			`RichText (sformat (_("<p>These packages from section '%1' are not available with selected repositories:</p>
<p>%2.</p>
<p>
You can remove the packages from the section, check the detailed package selection or ignore the situation.</p>
<p>
Going to detailed package selection and accepting the view without any further changes results in removal of problematic packages from the section.
</p>"), type_label, mergestring (sort (n_a), "<br>"))),
			`HBox (
			    // button label
			    `PushButton (`id (`remove), `opt (`default), _("Remove the packages")),
			    // button label
			    `PushButton (`id (`selection), _("Check package selection")),
			    // button label
			    `PushButton (`id (`ignore), ignore_allowed ? _("Ignore") : _("Cancel")) 
			)
		    )
		));
		any r	= UI::UserInput ();
		UI::CloseDialog ();
		if (r == `remove)
		{
		    KiwiConfig["packages",index,"package"]	= filter (map p, original_pmap["package"]:[], {
			return !contains (n_a, p["name"]:"");
		    });
		    ret	= `removed;
		}
		if (r == `selection)
		{
		    map sw_contents		= modifyPackageSelection (pmap);
		    if (sw_contents != nil)
		    {
			sw_contents["package"]  = union (sw_contents["package"]:[], bi_packages);
			KiwiConfig["packages",index]	= sw_contents;
			ret	= `selection;
		    }
		}
	    }
	}
	index	= index + 1;
    });

    return ret;
  }

  /**
   * Check if all selected packages and patterns can be installed
   * If dependency problem was found, open package selector.
   * Return false if package selector was canceled
   */
  define boolean CheckPackageDependencies () {

    boolean ret	= true;

    list<map> packages_section	= KiwiConfig["packages"]:[];
    integer index		= 0;
    foreach (map pmap, packages_section, {
	string type	= pmap["type"]:"";
	if (type != "delete")
	{
	    Pkg::ResolvableNeutral ("", `package, true);
	    Pkg::ResolvableNeutral ("", `pattern, true);

	    foreach (map pat, pmap["opensusePattern"]:[], {
		Pkg::ResolvableInstall(pat["name"]:"", `pattern);
	    });

	    ProductCreator::MarkTaboo (maplist (map i, pmap["ignore"]:[], ``(i["name"]:"")));

            // remember bootinclude packages: in Package selector we will lose this information (bnc#750739)
            map bi_packages	= $[];
            foreach (map p, KiwiConfig["packages",index,"package"]:[], {
	        if (p["bootinclude"]:"" == "true")
                {
                    bi_packages[p["name"]:""]   = true;
                }
		InstallPackageOrProvider (p["name"]:"");
            });
	    boolean solved = Pkg::PkgSolve (true);
	    if (!solved)
	    {
		map sw_contents		= modifyPackageSelection (KiwiConfig["packages",index]:$[]);
		if (sw_contents != nil)
		{
                    sw_contents["package"]      = maplist (map p, sw_contents["package"]:[], {
                        string name     = p["name"]:"";
                        if (bi_packages[name]:false)
                        {
                            y2milestone ("package %1 was marked as bootinclude", name);
                            p["bootinclude"]    = "true";
                        }
                        return p;
                    });
		    KiwiConfig["packages",index]	= sw_contents;
		}
		else
		{
		    ret	= false;
		}
	    }
	}
	index	= index + 1;
    });
    return ret;
  }


  /**
   * handler for main action: create the iso image with kiwi
   */
  define boolean CreateImage (string key, map event) {
    if (event["ID"]:nil != `next)
	return true;


    boolean ret	= true;
    map question	= $[
	// popup question
	"iso"	: _("Create ISO image now?"),
	// popup question
	"xen"	: _("Create Xen image now?"),
	// popup question
	"usb"	: _("Create USB stick image now?"),
	// popup question
	"vmx"	: _("Create virtual disk image now?"),
    ];

    map success		= $[
	// popup message, %1 is a dir
	"iso"	: _("ISO image successfully created in
%1
directory."),
	// popup message, %1 is a dir
	"xen"	: _("Xen image files successfully created in
%1
directory.
"),
	// popup message, %1 is a dir
	"usb"	: _("USB stick image successfully created in
%1
directory."),
	// popup message, %1 is a dir
	"vmx"	: _("Virtual disk image successfully created in
%1
directory."),
    ];

    boolean create_image_now	= false;
    string selected_profiles	= "";
    if (size (KiwiConfig["profiles"]:[]) > 0)
    {
	term items = `VBox (`VSpacing (0.5));
	list profiles = maplist (map prof,KiwiConfig["profiles",0,"profile"]:[],
	{
	    string name	= prof["name"]:"";
	    string desc	= prof["description"]:"";
	    items	= add (items, `Left (`CheckBox (`id (name),
		desc == "" ? name : sformat ("%1 (%2)", name, desc)))
	    );
	    return name;
	});
	UI::OpenDialog (`opt(`decorated), `HBox (`HSpacing (0.5), `VBox (
	    `VSpacing (0.5),
	    // popup label
	    `Label (question[kiwi_task]:_("Create image now?")),
	    items,
	    `HBox (
		`PushButton (`id(`yes),`opt(`key_F10), Label::YesButton()),
		`PushButton (`id(`no),`opt(`key_F9), Label::NoButton())
	    ),
	    `VSpacing (0.5)), `HSpacing (0.5))
	);
	while (true)
	{
	    any ret	= UI::UserInput ();
	    if (ret == `no)
	    {
		create_image_now	= false;
		break;
	    }
	    if (ret == `yes)
	    {
		create_image_now	= true;
		foreach (string name, (list<string>) profiles, {
		    if (UI::QueryWidget (`id (name), `Value) == true)
			selected_profiles	= selected_profiles +
			    " --add-profile " + name;
		});
		break;
	    }
	}
	UI::CloseDialog ();
    }
    else
    {
	create_image_now	=
	    // default question
	    Popup::YesNo (question[kiwi_task]:_("Create image now?"));
    }
    if (create_image_now)
    {
	if (CheckForAvailablePackages (false) == `missing)
	{
	    y2milestone ("there were missing packages, not going to build");
	    InitSWRichText ("rt_sw");
	    return false;
	}
	if (!CheckPackageDependencies ())
	{
	    y2milestone ("there was unresolved dependency problem, not going to build");
	    InitSWRichText ("rt_sw");
	    return false;
	}
	// write XML now, after possible modification of the package list
	Kiwi::WriteConfigXML (KiwiConfig, kiwi_task);

	    string out_dir	= KiwiConfig["iso-directory"]:"";
	    if (FileUtils::CheckAndCreatePath (out_dir) &&
		Kiwi::PrepareAndCreate (out_dir, selected_profiles))
	    {
		// default popup message, %1 is a dir
		Popup::Message (sformat (success[kiwi_task]:_("Image successfully created in
%1
directory."), out_dir));
	    }
	    else
	    {
		ret	= false;
	    }
    }
    else
    {
	Kiwi::WriteConfigXML (KiwiConfig, kiwi_task);
    }

    string dir	= Kiwi::SaveConfiguration (KiwiConfig, kiwi_task);
    if (dir != nil && dir != "")
    {
	ProductCreator::Config["kiwi_configuration_" + kiwi_task] = dir;
    }
    return ret;
  }

  /**
   * Global init function for Kiwi image dialog
   * - read saved settings and fill in defaults
   */
  define void InitImageConfiguration () {

    kiwi_task	= Kiwi::kiwi_task;


    // path to definition of openSUSE live CD (used if kiwi-config-openSUSE-kde,
    // resp. kiwi-config-openSUSE-gnome is installed)
    string kiwi_dir	= "/usr/share/openSUSE/kiwi-config-kde";
    if (!FileUtils::Exists (kiwi_dir))
	kiwi_dir	= "/usr/share/openSUSE/kiwi-config-gnome";

    // read the information from the base product
    integer src_id	= ProductCreator::checkProductDependency ();
    map<string,string> content = ProductCreator::ReadContentFile(src_id);

    KiwiConfig	= ProductCreator::Config;
    // busy popup
    Popup::ShowFeedback (_("Reading current image configuration..."), _("Please wait..."));

    // path to current config directory
    string default_dir	= (kiwi_task == "iso") ? kiwi_dir : "";
    string kiwi_configuration = KiwiConfig["kiwi_configuration_" + kiwi_task]:default_dir;
    if (kiwi_configuration == "" || !FileUtils::Exists (kiwi_configuration))
    {
	// use local template if default dir does not exist (bug #289552)
	if (!FileUtils::Exists (default_dir))
	{
	    default_dir = Directory::datadir+"/product-creator/kiwi_templates/";
	    default_dir	= default_dir + (kiwi_task == "xen" ? "xen" : "iso");
	}
	y2warning ("directory %1 is not available, using %2", kiwi_configuration, default_dir);
	kiwi_configuration	= default_dir;
    }

    if (FileUtils::Exists (kiwi_configuration + "/root"))
    {
	// read all entries from root_dir and save to list
	map out = (map) SCR::Execute (.target.bash_output,
	    sformat ("ls -A1 -d %1/root/* 2>/dev/null", kiwi_configuration));
	KiwiConfig["root_dir"]	= filter (string f, splitstring(out["stdout"]:"", "\n"), ``(f!=""));
    }
    if (FileUtils::Exists (kiwi_configuration + "/config"))
    {
	map out = (map) SCR::Execute (.target.bash_output,
	    sformat ("ls -A1 -d %1/config/* 2>/dev/null", kiwi_configuration));
	KiwiConfig["config_dir"] = filter (string f, splitstring(out["stdout"]:"", "\n"),``(f!=""));
    }

    foreach (string file, [ "images.sh", "config.sh" ], {
	string file_path	= kiwi_configuration + "/" + file;
	if (FileUtils::Exists (file_path))
	{
	    string contents	= (string) SCR::Read (.target.string, file_path);
	    if (contents != nil)
		KiwiConfig[file]	= contents;
	}
    });
    // take care of the rest in the input directory (#330052)
    list import_files	= [];
    map out = (map) SCR::Execute (.target.bash_output,
	sformat ("ls -A1 -d %1/* 2>/dev/null", kiwi_configuration));
    foreach (string line, splitstring (out["stdout"]:"", "\n"), {
	if (line == "") return;
	string last	= substring (line, findlastof (line, "/") + 1);
	if (contains (["images.sh", "config.sh", "config.xml", "root","config"],
	    last))
	    return;
	import_files	= add (import_files, line);
    });
    KiwiConfig["import_files"]	= import_files;

    map<string,any> read_config	= Kiwi::ReadConfigXML (kiwi_configuration);

    if (!KiwiConfig["_imported"]:false)
    {
	// "type" had different meaning in ProductCreator::Config...
	if (haskey (KiwiConfig, "type"))
	    KiwiConfig	= remove (KiwiConfig, "type");
	KiwiConfig = (map<string,any>) union (KiwiConfig, read_config);
	// do not read everything from the template, use the data defined in
	// Product Creator
	y2milestone ("product-creator based configuration...");

	KiwiConfig["sources"]	= ProductCreator::Config["sources"]:[];

	// find the set with 'image' packages
	integer index	= 0;
	integer i	= -1;
	foreach (map set, (list<map>) KiwiConfig["packages"]:[], {
	    i		= i + 1;
	    if (set["type"]:"" == "image")
	    {
		index	= i;
		break;
	    }
	});
	map sw_contents		= KiwiConfig["packages",index]:$[];
	sw_contents["opensusePattern"]	= maplist (string name,
	    ProductCreator::Config["addons"]:[], ``($[ "name" : name]));
	sw_contents["package"]	= maplist (string name,
	    ProductCreator::Config["packages"]:[], ``($[ "name" : name]));
	sw_contents["ignore"]	= maplist (string name,
	    ProductCreator::Config["taboo"]:[], ``($[ "name" : name]));

	KiwiConfig["packages",index]	= sw_contents;

	KiwiConfig["name"]	= ProductCreator::Config["name"]:"";
    }
    else
    {
	y2milestone ("imported configuration...");
	// ignore options already set earlier...
	foreach (string key, any val, read_config, {
	    if (!contains (["name", "sources", "version", "preferences"],key))
	    {
		KiwiConfig[key]	= val;
	    }
	});
	list<map> pref	= KiwiConfig["preferences"]:[];
	// new configuration doesn't get preferences at all...
	if (pref == [])
	{
	    pref		= read_config["preferences"]:[];
	    pref[0,"version"]	= [ $[
		content_key	: "1.0.0"
	    ]];
	    KiwiConfig["preferences"]	= pref;
// FIXME check if boot directories match current product (-> enable building
// for product different from installed one)
	}
	else
	{
	    // existing defaultdestination needs to be used as iso-dirctory as well
	    // (correct iso-directory was replaced on import (bnc#499489)
	    string dest     = get_preferences (KiwiConfig, "defaultdestination", "");
	    if (dest != "")
		KiwiConfig["iso-directory"]     = dest;
	}
	boolean primary_included	= false;
	string boot_dir			= "";
	// set the primary building target according to kiwi_task
	KiwiConfig["preferences",0,"type"]	= maplist (
	    map typemap, (list<map>)pref[0,"type"]:[],
	{
	    string type	= typemap["image"]:"";
	    if (tolower (typemap["primary"]:"false") == "true" && type != kiwi_task)
		typemap	= remove (typemap, "primary");
	    else if (type == kiwi_task)
	    {
		typemap["primary"]	= "true";
		primary_included	= true;
	    }
	    if (boot_dir == "")
		boot_dir	= typemap["boot"]:"";
	    return typemap;
	});
	// add the new type, that was not previously defined in config.xml
	// read the default values for this type from the template
	if (!primary_included)
	{
	    if (default_dir == "")
	    {
		default_dir =
		    Directory::datadir+"/product-creator/kiwi_templates/";
		default_dir = default_dir + (kiwi_task== "xen" ? "xen" : "iso");
	    }
	    map<string,any> def_map = Kiwi::ReadConfigXML (default_dir);
	    foreach (map typemap, (list<map>)def_map["preferences",0,"type"]:[],
	    {
		if (typemap["image"]:"" == kiwi_task)
		{
		    KiwiConfig["preferences",0,"type"]	= add (
			KiwiConfig["preferences",0,"type"]:[], typemap);
		    break;
		}
	    });
	}
	// save the info about packages and patterns into ProductCreator::Config
	// ("sources" are already there...)
	map sw_contents	= KiwiConfig["packages",0]:$[];
	ProductCreator::Config["addons"]	= maplist (
	    map pat, sw_contents["opensusePattern"]:[], ``(pat["name"]:""));
	ProductCreator::Config["packages"]	= maplist (
	    map pat, sw_contents["package"]:[], ``(pat["name"]:""));
	ProductCreator::Config["taboo"]		= maplist (
	    map pat, sw_contents["ignore"]:[], ``(pat["name"]:""));
    }
    map label2boot	= $[
	    "openSUSE 11.0"	: "suse-11.0",
	    "openSUSE 11.1"	: "suse-11.1",
	    "SUSE Linux Enterprise Server 10"	: "suse-SLES10",
	    "SUSE Linux Enterprise Desktop 10"	: "suse-SLED10",
	    "SUSE Linux Enterprise Desktop 10 SP2" : "suse-SLED10-SP2",
            "SUSE Linux Enterprise Server 10 SP2" : "suse-SLES10-SP2",
	    "SUSE Linux Enterprise Server 11"	: "suse-SLES11",
	    "SUSE Linux Enterprise Desktop 11"	: "suse-SLED11",
    ];
    string contentlabel	= String::CutBlanks (content["LABEL"]:"");
    string boot_image	= label2boot[contentlabel]:"";

    // guess some default boot image value
    if (kiwi_task == "iso" && !haskey (KiwiConfig, "isoboot") && boot_image != "")
    {
	KiwiConfig["isoboot"]	= boot_image;
    }
    else if (kiwi_task == "usb")
    {
	if (!haskey (KiwiConfig, "usbboot") && boot_image != "")
	    KiwiConfig["usbboot"]	= boot_image;
    }
    else if (kiwi_task == "vmx")
    {
	if (!haskey (KiwiConfig, "vmxboot") && boot_image != "")
	    KiwiConfig["vmxboot"]	= boot_image;
    }
    else if (kiwi_task == "xen")
    {
	if (!haskey (KiwiConfig, "xenboot"))
	    KiwiConfig["xenboot"]	= boot_image;
    }
    string name		= KiwiConfig["name"]:"";
    Popup::ClearFeedback ();
  }


  /****************************************************************************
   * widget descriptions
   ****************************************************************************/

  // return map with description of tabs
  // it is a function, to be able to adapt to actual state)
  map tabs_descr () {

    boolean show_compression	= true;

    // compression not allowed in most cases (bnc#510833)
    foreach (map typemap, (list<map>)KiwiConfig["preferences",0,"type"]:[], {
	if (typemap["image"]:"" == kiwi_task)
	{
	    if (typemap["filesystem"]:"" == "ext3")
		show_compression	= false;
	}
    });

    map ret	= $[
      "config.xml" : $[
	// tab header
	"header"	: _("Image Configuration"),
	"contents"	: `HBox (`HSpacing(1),
	    `VBox (
		`VSpacing (0.2),
		`HBox (
		    `HWeight (2, `HBox (
			"version", "size", "sizeunit",
			`VBox (
			    `Label (""),
			    "additive"
			)
		    )),
		    show_compression ? `HWeight (1, "compression") : `HBox ()
		),
		`HBox (
			`VBox (
			    `Label (""),
			    "encrypt_disk"
			),
			"disk_password"
		),
		`HBox (
		    `HWeight (2, `VBox (
			"sw_selection",
			`Left (`Label (_("Installed Software"))),
			"rt_sw",
			`Right ("configure_sw")
		    )),
		    `HWeight (1, "delete_sw")
		),
		`VSpacing (0.2)
	    ), `HSpacing(1)),
	"widget_names" : [
	    "version",
	    "size", "sizeunit", "additive",
	    "encrypt_disk", "disk_password",
	    "sw_selection",
	    "rt_sw", "configure_sw",
	    "delete_sw",
	],
    ],
    "description" : $[
	// tab header
	"header"	: _("Description"),
	"contents"	: `HBox (`HSpacing(1),
	    `VBox (
		`VSpacing (0.2),
		"author",
		`VSpacing (0.2),
		"contact",
		`VSpacing (0.2),
		"specification",
		`VSpacing (0.6),
		// frame label
		`Frame (_("Locale settings"), `HBox (
		    "locale",
		    "keytable",
		    "timezone"
		)),
		`VStretch ()
	    ), `HSpacing (1)),
	"widget_names" : [
	    "author", "contact", "specification", "locale", "keytable",
	    "timezone"
	],
    ],
    "users" : $[
	// tab header
	"header"	: _("Users"),
	"contents"	: `HBox (`HSpacing(1),
	    `VBox (
		"general_users",
		`VSpacing (0.2),
		"userstable",
		`VSpacing (0.2),
		`HBox ("adduser", "edituser", "deleteuser", `HStretch ()),
		`VSpacing (0.2)
	    ), `HSpacing (1)),
	"widget_names" : [
	    "general_users", "group", "userstable", "adduser", "edituser", "deleteuser"
	]
    ],
    "scripts" : $[
	// tab header
	"header"	: _("Scripts"),
	"contents"	: `HBox (`HSpacing(1),
	    `VBox (
		"general_scripts",
		`VSpacing (0.2),
		`HBox ("config.sh", `Bottom ("import_config.sh")),
		`HBox ("images.sh", `Bottom ("import_images.sh")),
		`VSpacing (0.2)
	    ), `HSpacing (1)),
	"widget_names" : [
	    "general_scripts",
	    "config.sh", "import_config.sh",
	    "images.sh", "import_images.sh",
	],
    ],
    "directories" : $[
	// tab header
	"header"	: _("Directories"),
	"contents"	: `HBox (`HSpacing(1),
	    `VBox (
		"general_directories",
		`VSpacing (0.2),
		"root_dir_table",
		`VSpacing (0.2),
		`HBox ("root_dir_add", `Left ("root_dir_delete")),
		`VSpacing (0.2),
		"config_dir_table",
		`VSpacing (0.2),
		`HBox ("config_dir_add", `Left ("config_dir_delete")),
		`VSpacing (0.2),
		`VSpacing (0.2)
	    ), `HSpacing (1)),
	"widget_names" : [
	    "general_directories",
	    "root_dir_table", "root_dir_add", "root_dir_delete",
	    "config_dir_table", "config_dir_add", "config_dir_delete",
	],
      ],
    ];
    if (show_compression)
	ret["config.xml","widget_names"]	= add (
	    ret["config.xml","widget_names"]:[], "compression");
    return ret;
  }

  map<string, map> get_widget_description () {
    return $[
    // global widgets
    "global"		:$[
	"widget"	: `empty,
	"validate_type"	: `function,
	"validate_function"	: CreateImage,
	"no_help"	: true,
    ],
    "compression" : $[
	"widget"	: `combobox,
	"opt"		: [ `hstretch, `notify ],
	"items"		: [],
	// textentry label
	"label"		: _("Co&mpression"),
	// help text
	"help"		:_("<p>Select the value for image <b>Compression</b>. This will modify the <i>flags</i> value of the image type. Check the kiwi manual for the meaning of the available values.</p>"),
	"init"		: InitCompressionCombo,
	"store"		: StoreCompressionCombo,
	"handle"	: HandleCompressionCombo,
    ],
    "sw_selection"	: $[
	"widget"	: `combobox,
	"opt"		: [ `hstretch, `notify ],
	// combo box label
	"label"		: _("So&ftware Selection"),
	// help text for "So&ftware selection"
	"help"		: "",
	"items"		: [],
	"init"		: InitSWSelectionCombo,
	"store"		: StoreSWSelectionCombo,
	"handle"	: HandleSWSelectionCombo,
    ],
    "rt_sw"		: $[
	"widget"	: `richtext,
	"init"		: InitSWRichText,
	"help"		: "",
	"label"		: "&L",
    ],
    "configure_sw"	: $[
	"widget"        : `push_button,
	// pusbutton label
	"label"         : _("Ch&ange..."),
	"help"		: _("<p>Adapt the software selection with <b>Change</b>.</p>"),
	"handle"	: HandleSWSelection
    ],
    "ignore"	: $[
	"widget"	: `multi_line_edit,
	// label
	"label"		: _("&Ignored Software"),
	"init"		: InitSWIgnore,
	"store"		: StoreSWIgnore,
	"handle"	: HandleSWIgnore,
	// help text for "&Ignored software"
	"help"		: _("<p>For <b>ignored software</b>, enter each entry (like 'smtp_daemon') on new line</p>"),
    ],
    "delete_sw"	: $[
	"widget"	: `multi_line_edit,
	// label
	"label"		: _("Packages to &Delete"),
	"init"		: InitSWDelete,
	"store"		: StoreSWDelete,
	"handle"	: HandleSWDelete,
	// help text for "&Ignored software"
	"help"		: _("<p>Each entry of <b>Packages to Delete</b> is one package name to be uninstalled from the target image.</p>"),
    ],
    "version" : $[
	"widget"	: `textentry,
	// textentry label
	"label"		: _("&Version"),
	"help"		: _("<p>Enter the <b>Version</b> of your image configuration.</p>"),
	"valid_chars"	: String::CDigit () + ".",
	"init"		: InitVersion,
	"store"		: StoreVersion,
	"handle"	: HandleVersion,
    ],
    "size" : $[
	"widget"	: `intfield,
	"opt"		: [ `hstretch ],
	// textentry label
	"label"		: _("&Size"),
	// help text for "Size" field and "Additive" checkbox
	"help"		: _("<p>Set the image <b>Size</b> in the specified <b>Unit</b>.
If <b>Additive</b> is checked, the meaning of <b>Size</b> is different: it is the minimal free space available on the image.</p>"),
	"init"		: InitSize,
	"store"		: StoreSize,
	"handle"	: HandleSize,
    ],
    "sizeunit" : $[
	"widget"	: `combobox,
	// combo box label (MB/GB values)
	"label"		: _("&Unit"),
	"no_help"	: true,
	"items"		: [],
	// stored and handled by "size"
    ],
    "additive" : $[
	"widget"	: `checkbox,
	// check box label
	"label"		: _("Additive"),
	"no_help"	: true,
    ],
    "encrypt_disk"	: $[
	"widget"	: `checkbox,
	"opt"		: [ `notify ],
	// check box label
	"label"		: _("Encrypt Image with LUKS"),
	// help text
	"help"		: _("<p>For creating encrypted file system, check <b>Encrypt Image with LUKS</b> and enter the password.</p>"),
	"handle"	: HandleEncryptDisk,
    ],
    "disk_password" : $[
	"widget"	: `textentry,
	// textentry label
	"label"		: _("Encrypted Image LUKS Password"),
	"init"		: InitDiskPassword,
	"store"		: StoreDiskPassword,
	"handle"	: HandleDiskPassword,
	"no_help"	: true,
    ],
    // ---------------- widgtes for directory structure
    "general_scripts"	: $[
	"widget"	: `empty,
	// general help for directory structure tab
	"help"		: _("<p>Here, edit the configuration scripts used to build your image.</p>"),
    ],
    "general_directories"	: $[
	"widget"	: `empty,
	// general help for directory structure tab
	"help"		: _("<p>Here, point to the configuration directories that should help to build your image.</p>"),
    ],
    "root_dir"		: $[
	"widget"	: `textentry,
	// textentry label
	"label"		: _("Directory with System Configur&ation"),
	// help text
	"help"		: _("<p>Define the path to the <b>Directory with System Configuration</b> (the <tt>root</tt> directory). The entire directory is copied into the root of the image tree using <tt>cp -a</tt>.</p>"),
	"init"		: InitGeneric,
	"store"		: StoreGeneric,
	"handle"	: HandleGeneric,
    ],
    "browse_root_dir"	: $[
	"widget"	: `push_button,
	"label"		: Label::BrowseButton (),
	"help"		: "",
	"handle"	: HandleBrowseRootDirectory
    ],
    "root_dir_table" : $[
	"widget"	: `custom,
	"custom_widget" : `VBox (
	    // label (above table)
	    `Left (`Label (_("Directory with System Configuration"))),
	    `Table (`id("roottable"), `header (
		// table header
		_("Path to Directory"))
	    )
	),
	// help for table with users
	"help"		: _("<p>Configure the <b>Directory with System Configuration</b> (the <tt>root</tt> directory). The entire directory is copied into the root of the image tree using <tt>cp -a</tt>.</p>"),
	"init"		: InitRootDirTable,
    ],
    "root_dir_add"	: $[
	"widget"	: `push_button,
	"label"		: Label::AddButton (),
	"no_help"	: true,
	"handle"	: HandleAddToRootDir,
    ],
    "root_dir_delete"	: $[
	"widget"	: `push_button,
	"label"		: Label::DeleteButton (),
	"no_help"	: true,
	"handle"	: HandleDeleteFromRootDir,
    ],
    "config_dir_table" : $[
	"widget"	: `custom,
	"custom_widget" : `VBox (
	    // label (above table)
	    `Left (`Label (_("Directory with Scripts"))),
	    `Table (`id("configtable"), `header (
		// table header
		_("Path to File"))
	    )
	),
	// help for table with users
	"help"		: _("<p>Configure the <b>Directory with Scripts</b> (the <tt>config</tt> directory). It contains scripts that are run after the installation of all the image packages.</p>"),
	"init"		: InitConfigDirTable,
    ],
    "config_dir_add"	: $[
	"widget"	: `push_button,
	"label"		: Label::AddButton (),
	"no_help"	: true,
	"handle"	: HandleAddToConfigDir,
    ],
    "config_dir_delete"	: $[
	"widget"	: `push_button,
	"label"		: Label::DeleteButton (),
	"no_help"	: true,
	"handle"	: HandleDeleteFromConfigDir,
    ],
    "config.sh" : $[
	"widget"	: `multi_line_edit,
	// textentry label
	"label"		: _("I&mage Configuration Script"),
	"help"		: _("<p>Edit your <b>Image Configuration Script</b>, called <tt>config.sh</tt>. This script is run at the end of the installation but before the package scripts have run.</p>"),
	"init"		: InitGeneric,
	"store"		: StoreGeneric,
	"handle"	: HandleGeneric,
    ],
    "import_config.sh" : $[
	"widget"	: `push_button,
	// textentry label
	"label"		: _("&Import..."),
	"help"		: "",
	"handle"	: HandleImportConfigFile
    ],
    "config_dir" : $[
	"widget"	: `textentry,
	// textentry label
	"label"		: _("Pa&th to Directory with Scripts"),
	"help"		: _("<p>The optional <b>Directory with Scripts</b> (<tt>config</tt> directory) contains scripts that are run after the installation of all the image packages.</p>"),
	"init"		: InitGeneric,
	"store"		: StoreGeneric,
	"handle"	: HandleGeneric,
    ],
    "browse_config_dir"	: $[
	"widget"	: `push_button,
	// push button label
	"label"		: _("Br&owse..."),
	"help"		: "",
	"handle"	: HandleBrowseConfigDirectory
    ],
    "autoyast_path" : $[
	"widget"	: `textentry,
	// textentry label
	"label"		: _("Path to Auto&YaST Profile"),
	"help"		: _("Choose the path to the AutoYaST profile (config.xml)."),
    ],
    "browse_autoyast"	: $[
	"widget"	: `push_button,
	// push button label
	"label"		: _("Brow&se..."),
	"help"		: "",
	"handle"	: HandleBrowseAutoYaSTFile
    ],
    "images.sh" : $[
	"widget"	: `multi_line_edit,
	// textentry label
	"label"		: _("C&leanup Script"),
	"help"		: _("<p>Edit your <b>Cleanup Script</b> (<tt>images.sh</tt>). This script is run at the beginning of the image creation process.</p>"),
	"init"		: InitGeneric,
	"store"		: StoreGeneric,
	"handle"	: HandleGeneric,
    ],
    "import_images.sh" : $[
	"widget"	: `push_button,
	// textentry label
	"label"		: _("Im&port..."),
	"help"		: "",
	"handle"	: HandleImportImagesFile
    ],
    // ---------------- widgtes for description tab
    "author" : $[
	"widget"	: `textentry,
	// textentry label
	"label"		: _("&Author"),
	// help text for Author, Contact and Specification widgets
	"help"		: _("<p>Set the values for <b>Author</b> of the image, <b>Contact Information</b>, and the image <b>Specification</b>.</p>"),
	"init"		: InitDescription,
	"store"		: StoreDescription,
	"handle"	: HandleDescription,
    ],
    "contact" : $[
	"widget"	: `textentry,
	// textentry label
	"label"		: _("C&ontact"),
	"init"		: InitDescription,
	"store"		: StoreDescription,
	"handle"	: HandleDescription,
	"no_help"	: true,
    ],
    "specification" : $[
	"widget"	: `multi_line_edit,
	// textentry label
	"label"		: _("&Specification"),
	"init"		: InitDescription,
	"store"		: StoreDescription,
	"handle"	: HandleDescription,
	"no_help"	: true,
    ],
    "locale" : $[
	"widget"	: `combobox,
	"opt"		: [ `hstretch, `notify ],
	"items"		: [],
	// textentry label
	"label"		: _("&Locale"),
	"init"		: InitLocaleCombo,
	"store"		: StorePreferences,
	"handle"	: HandlePreferences,
	// help text for locale (heading)
	"help"		: _("<p><b>Locale Settings</b></p>") +
	// help text for locale
	_("<p>The value of <b>Locale</b> (e.g. <tt>en_US</tt>) defines the contents of the RC_LANG variable in <t>/etc/sysconfig/language</tt>.</p>"),
    ],
    "keytable" : $[
	"widget"	: `combobox,
	"opt"		: [ `hstretch, `notify, `editable ],
	// textentry label
	"label"		: _("&Keyboard layout"),
	"init"		: InitKeytableCombo,
	"store"		: StorePreferences,
	"handle"	: HandlePreferences,
	// help text for keytable
	"help"		: _("<p><b>Keyboard layout</b> specifies the name of the console keymap to use. The value corresponds to a map file in <tt>/usr/share/kbd/keymaps</tt>.</p>"),
    ],
    "timezone" : $[
	"widget"	: `combobox,
	"opt"		: [ `hstretch, `notify ],
	"items"		: [],
	// textentry label
	"label"		: _("&Time zone"),
	"init"		: InitTimezoneCombo,
	"store"		: StorePreferences,
	"handle"	: HandlePreferences,
	// help text for timezone
	"help"		: _("<p>It is also possible to set a specific <b>Time zone</b>. Available time zones are located in the <tt>/usr/share/zoneinfo</tt> directory.</p>"),
    ],
    // ---------------- widgtes for users tab
    "general_users"	: $[
	"widget"	: `empty,
	// general help for users tab
	"help"		: _("<p>Here, create users that should be available in the target system.</p>"),
    ],
    "userstable" : $[
	"widget"	: `custom,
	"custom_widget" : `Table (`id("table"), `opt (`notify), `header(
			    // table header
			    _("Login Name"),
			    // table header
			    _("Full Name"),
			    // table header
			    _("UID"),
			    // table header
			    _("Home Directory"),
			    // table header
			    _("Group"),
			    // table header
			    _("GID"))
	),
	// help for table with users
	"help"		: _("<p>For each user, specify the <b>Name</b>, <b>Password</b>, <b>Home Directory</b> and group
to which the users belongs.</p>
"),
	"init"		: InitUsersTable,
	"handle"	: HandleAddEditUser,
    ],
    "adduser"	: $[
	"widget"	: `push_button,
	"label"		: Label::AddButton (),
	"no_help"	: true,
	"handle"	: HandleAddEditUser,
    ],
    "edituser"	: $[
	"widget"	: `push_button,
	"label"		: Label::EditButton (),
	"no_help"	: true,
	"handle"	: HandleAddEditUser,
    ],
    "deleteuser"	: $[
	"widget"	: `push_button,
	"label"		: Label::DeleteButton (),
	"no_help"	: true,
	"handle"	: HandleDeleteUser,
    ],
    // ------------------
    ];
  }


  /**
   * Main dialog for Kiwi image configuration
   */
define symbol KiwiDialog () {

InitImageConfiguration ();

if (CheckForAvailablePackages (true) != `selection)
{
    CheckPackageDependencies ();
}

map<string, map> widget_descr	= get_widget_description ();
widget_descr["tab"] = CWMTab::CreateWidget($[
    "tab_order"	: [
	"config.xml", "description", "users", "scripts", "directories"
    ],
    "tabs"		: tabs_descr (),
    "widget_descr"	: widget_descr,
    "initial_tab"	: "config.xml",
]);
Wizard::SetContentsButtons("", `VBox (), "", Label::BackButton(), Label::NextButton());
term contents	= `VBox (
    `Left (`Label (KiwiConfig["name"]:"")),
    "tab",
    `VSpacing (0.3),
    "global"
);

map caption		= $[
    // dialog caption
    "iso"	: _("Live CD Configuration"),
    // dialog caption
    "xen"	: _("Xen Image Configuration"),
    // dialog caption
    "usb"	: _("USB Stick Image Configuration"),
    // button label
    "vmx"	: _("Virtual Disk Image"),
];
map next_button	= $[
    // button label
    "iso"	: _("&Create ISO"),
    // button label
    "xen"	: _("&Create Xen Image"),
    // button label
    "usb"	: _("&Create USB Stick Image"),
    // button label
    "vmx"	: _("&Create Virtual Disk Image"),
];
symbol ret = CWM::ShowAndRun ($[
    "widget_names"		: [ "global", "tab" ],
    "widget_descr"		: widget_descr,
    "contents"		: contents,
    // default dialog caption
    "caption"		: caption[kiwi_task]:_("Image Configuration"),
    "back_button"		: Label::BackButton (),
//	"next_button"		: next_button[kiwi_task]:Label::NextButton (),
    "next_button"		: Label::FinishButton (),
    "fallback_functions"    : $[
        `abort		: ProductCreator::ReallyAbort
    ],
]);
y2milestone("Returning %1", ret);
return ret;
}

  /**
   * Prepare dialog: define kiwi data without product-creator
   */
  define symbol PrepareDialog () {

    kiwi_task			= Kiwi::kiwi_task;
    if (kiwi_task == "")
	kiwi_task	= "iso";

    map<string,any> Config	= ProductCreator::Config;
    string kiwi_configuration	= Config["kiwi_configuration_" + kiwi_task]:"";
    string name			= Config["name"]:"";
    string out_dir		= Config["iso-directory"]:"/tmp";
    map <string,map> repositories	= Kiwi::current_repositories;
    boolean new_configuration	= (Config == $[]);
    boolean append_name		= false;

    string help	= (new_configuration ?
	// help text for kiwi UI preparation
	_("<p>Enter the name of your image configuration. Base new configuration on template from the list or on the directory with the existing configuration.</p>")
	: "") +

    // help text for kiwi UI preparation
    (new_configuration ? sformat (_("<p>Place custom configuration templates under <tt>%1</tt> directory.</p>"), Kiwi::templates_dirs[0]:"") : "") +

    // help text for kiwi UI preparation, cont.
    _("<p>Choose the <b>Image Type</b> which should be created.</p>") +

    // help text for kiwi UI preparation, cont.
    _("<p>Select <b>Output Directory</b> for the created image.</p>") +

    // help text for kiwi UI preparation, cont.
    _("<p>Modify the list of <b>Package Repositories</b> that will be used for creating the image. Use <b>Add From System</b> to add one of the current system repositories.</p>") +

    // help text for kiwi UI preparation, cont.
    _("<p>Use <b>Next</b> to continue with the configuration.</p>");

    list basic_type_items	= [
	    // combo box item
	    `item (`id ("xen"), _("Xen Image"), kiwi_task == "xen"),
	    // combo box item
	    `item (`id ("usb"), _("USB Stick Image"), kiwi_task == "usb"),
	    // combo box item
	    `item (`id ("vmx"), _("Virtual Disk Image"), kiwi_task == "vmx")
    ];

    // build Live iso only for x86_64 and i386 (bnc#675101)
    if (Arch::architecture () == "x86_64" || ProductCreator::GetArch () == "i386")
    {
	basic_type_items	= prepend (basic_type_items,
	    // combo box item
	    `item (`id ("iso"), _("Live ISO Image"), kiwi_task == "iso")
	);
    }

    map task2label	= $[
	// combo box item
	"pxe"	: _("Network Boot Image"),
	// combo box item
	"iso"	: _("Live ISO Image"),
	// combo box item
	"xen"	: _("Xen Image"),
	// combo box item
	"usb"	: _("USB Stick Image"),
	// combo box item
	"vmx"	: _("Virtual Disk Image"),
	// combo box item
	"oem"	: _("OEM Image")
    ];

    list type_items		= basic_type_items;
    list default_type_items	= basic_type_items;

    string supported_images	= Kiwi::supported_boot_images;
    if (supported_images != "" && supported_images != "template")
    {
	type_items	= []; // will be read from template..., or:
	foreach (string type, splitstring (supported_images,","),
	{
	    if (haskey (task2label, type))
	    {
		type_items	= add (type_items,
		    `item (`id (type),task2label[type]:type,type == kiwi_task));
	    }
	});
	default_type_items	= type_items;
    }
    else if (supported_images == "template" && !new_configuration)
    {
	list type_its	= [];
	//solve `back here (=no import)
	foreach (map typemap, (list<map>) Config["preferences",0,"type"]:[], {
	    string type	= typemap["image"]:"";
	    type_its	= add (type_its,
		`item (`id (type), task2label[type]:type, type == kiwi_task));
	});
	if (type_its != [])
	    type_items	= type_its;
    }
    list present_types	= maplist (
	term it, (list<term>)type_items, ``(it[0,0]:""));
    if (!contains (["iso", "xen", "usb", "vmx"], kiwi_task) &&
	!contains (present_types, kiwi_task))
    {
	type_items	= add (type_items,
	    `item (`id (kiwi_task), task2label[kiwi_task]:kiwi_task, true));
	present_types	= add (present_types, kiwi_task);
    }

    // on start, show the default YaST sources
    if (Config["sources"]:[] != [] && repositories == $[])
    {
	foreach (string src, Config["sources"]:[], {
	    repositories[src]	= $[
		"url"		: src,
	    ];
	});
    }
    list system_repo_items	= maplist (string url, map repo,
	Kiwi::initial_repositories, {
	    return `item (`id (url), url);
    });

    void update_repo_table () {
	UI::ChangeWidget (`id (`repositories), `Items, maplist (
	    string url, map repo, repositories, ``(
		`item (`id (url), url))
	));
	UI::ChangeWidget (`id (`delete), `Enabled, size (repositories) > 0);
    }

    // read the new configuration and update UI accordingly
    // (no need to read config if it is provided as argument)
    boolean update_config (string dir, map config) {

	kiwi_configuration	= dir;
	Config			=
	    (config == $[] ? Kiwi::ReadConfigXML (kiwi_configuration) : config);

	if (Config["description",0,"type"]:"" != "system")
	{
	    y2warning ("%1 does not have 'system' image type, skipping", dir);
	    // error popup
	    Popup::Error (_("Selected directory does not contain valid description of system configuration"));
	    return false;
	}

	// busy popup
	Popup::ShowFeedback (_("Importing repositories..."), _("Please wait..."));
	repositories		= Kiwi::ImportImageRepositories (Config, dir);
	Popup::ClearFeedback ();
	if (!new_configuration)
	{
	    name		= Config["name"]:"";
	    UI::ChangeWidget (`id (`config), `Value, name);
	}
	else
	{
	    Config	= save_preferences (Config, "version", "1.0.0");
	}
	if (Config["iso-directory"]:"" != "")
	    UI::ChangeWidget(`id(`out_dir), `Value, Config["iso-directory"]:"");
	update_repo_table ();
	list type_its = supported_images != "template" ? default_type_items: [];

	kiwi_task	= "";
	foreach (map typemap, (list<map>) Config["preferences",0,"type"]:[], {
	    string type	= typemap["image"]:"";
	    if (tolower (typemap["primary"]:"false") == "true" || kiwi_task == "")
		kiwi_task	= type;
	    if ((supported_images == "" && !contains (present_types, type)) ||
		supported_images == "template")
	    {
		type_its	= add (type_its,
		    `item (`id (type), task2label[type]:type));
		present_types	= union (present_types, [type]);
	    }
	});
	if (kiwi_task == "")
	{
	    kiwi_task	= "iso";
	    y2warning ("no task found, setting to 'iso'");
	}
	UI::ChangeWidget (`id (`type), `Items, type_its);
	UI::ChangeWidget (`id (`type), `Value, kiwi_task);
	return true;
    }

    list template_items	= maplist (string dir, map template, Kiwi::Templates, {
	return `item (`id (dir), sformat (
	    // combo box item, %1 is name, %2 version
	    _("%1, version %2"), template["name"]:"", get_preferences (template, "version", ""))
	);
    });

    term arch_term	= `VBox ();

    if (Arch::architecture () == "x86_64")
    {
	arch_term	= `VBox (
	    // checkbox label
	    `CheckBox (`id (`i386), `opt (`notify, `hstretch), _("&32bit Architecture Image"),
		Kiwi::image_architecture == "i386"),
	    `VSpacing (0.2)
	);
    }
    arch_term	= add (arch_term,
	// checkbox label
	`CheckBox (`id (`i586), `opt (`hstretch), _("Target is i586 only"), Kiwi::target_i586));
    arch_term	= add (arch_term, `VSpacing (0.2));

    term contents	= `VBox (
	new_configuration ?
	`VBox (
	    `InputField (`id (`config), `opt (`hstretch),
		// text entry label
		_("&Kiwi configuration"), name),
	    `RadioButtonGroup (`id (`imp), `HBox (`HSpacing (), `VBox (
		`VSpacing (0.2),
		`Left (`RadioButton (`id ("rb_new"), `opt (`notify),
		    // radio button label
		    _("Create from beginning"), true)
		),
		template_items == [] ? `VSpacing (0) :
		`Left (`RadioButton (`id ("rb_template"), `opt (`notify),
		    // radio button label
		    _("Base on Template"))
		),
		template_items == [] ? `VSpacing (0) :
		`HBox (
		    `HSpacing (2.5),
		    `ComboBox (`id (`template), `opt (`notify, `hstretch), "",
			template_items)
		),
		`Left (`RadioButton (`id ("rb_dir"), `opt (`notify),
		    // radio button label
		    _("Base on Existing Configuration"))
		),
		`HBox (
		    `HSpacing (2.5),
		    `Label (`id (`import_dir),`opt (`outputField,`hstretch),""),
		    // push button label
		    `PushButton (`id (`import), _("&Choose..."))
		)
	    )))
	) :
	`Left (`Label (`id (`config), name)),
	// combo box label
	`ComboBox (`id (`type), `opt (`notify, `hstretch), _("I&mage Type"),
	    type_items),
	`HBox (
	    `InputField (`id (`out_dir), `opt (`hstretch),
		// text entry label
		_("&Output directory"), out_dir),
	    `VBox (
		`Label (""),
		`PushButton (`id (`browse), Label::BrowseButton ())
	    )
	),
	`VSpacing (0.2),
	arch_term,
	`Table (`id(`repositories), `opt (`notify), `header (
	    // table header
	    _("Package Repository"))
	),
	`HBox (
	    `PushButton (`id (`add), Label::AddButton ()),
	    // menu butto label
	    `MenuButton (`id (`addsystem), _("A&dd From System"),
		system_repo_items),
	    `PushButton (`id (`edit), Label::EditButton ()),
	    `PushButton (`id (`delete), Label::DeleteButton ()),
	    `HStretch ()
	)
    );
    // dialog caption
    Wizard::SetContentsButtons (_("Image preparation"), contents, help,
	Label::BackButton(), Label::NextButton());
    Wizard::RestoreBackButton();
    Wizard::RestoreAbortButton();

    if (new_configuration && kiwi_configuration != "")
    {
	update_config (kiwi_configuration, $[]);
    }
    else
	update_repo_table ();

    if (new_configuration)
    {
	UI::SetFocus (`id (`config));
	if (template_items != [])
	    UI::ChangeWidget (`id (`template), `Enabled, false);
	UI::ChangeWidget (`id (`import), `Enabled, false);
	UI::ChangeWidget (`id (`config), `ValidChars, String::CAlnum ()+".-_");
    }
    if (Arch::architecture () == "x86_64")
    {
	UI::ChangeWidget (`id (`i586), `Enabled, Kiwi::image_architecture == "i386");
    }
    any ret = nil;
    while (true)
    {
	ret = UI::UserInput();
	if (ret == `abort || ret == `cancel || ret == `back)
	{
	    if(ProductCreator::ReallyAbort()) break;
            else continue;
	}
	else if (ret == "rb_dir")
	{
	    if (template_items != [])
		UI::ChangeWidget (`id (`template), `Enabled, false);
	    UI::ChangeWidget (`id (`import), `Enabled, true);
	    if (kiwi_configuration == "")
		ret = `import;
	}
	else if (ret == "rb_template")
	{
	    UI::ChangeWidget (`id (`template), `Enabled, true);
	    UI::ChangeWidget (`id (`import), `Enabled, false);
	    ret	= `template;
	}
	else if (ret == "rb_new")
	{
	    UI::ChangeWidget (`id (`template), `Enabled, false);
	    UI::ChangeWidget (`id (`import), `Enabled, false);
	}
	if (ret == `i386)
	{
	    UI::ChangeWidget (`id (`i586), `Enabled, UI::QueryWidget (`id (`i386), `Value));
	}
	if (ret == `import)
	{
	    string dir	= UI::AskForExistingDirectory (
		kiwi_configuration== "" ? Kiwi::images_dir : kiwi_configuration,
		// popup for file selection dialog
		_("Directory to Import"));
	    if (dir!= nil && update_config (dir, $[]))
	    {
		UI::ChangeWidget (`id (`import_dir), `Value, dir);
	    }
	}
	else if (ret == `template)
	{
	    string dir	= (string) UI::QueryWidget (`id (`template), `Value);
	    update_config (dir, Kiwi::Templates[dir]:$[]);
	}
	else if (is (ret, string) && // system repository selected
	    ret != "rb_dir" && ret != "rb_new")
	{
	    map system_repo	= Kiwi::initial_repositories[(string)ret]:$[];
	    if (!haskey (repositories, (string)ret))
		repositories[(string)ret]	= system_repo;

	    update_repo_table ();
	}
	else if (ret == `add)
	{
	    Wizard::CreateDialog ();
	    string url		= "";
	    symbol type_ret	= SourceDialogs::TypeDialog ();

	    if ((type_ret == `next || type_ret == `finish))
	    {
		if (type_ret == `finish && SourceDialogs::GetURL () == "slp://")
		{
		    string required_package = "yast2-slp";
		    boolean installed_before = PackageSystem::Installed (required_package);
		    if (! installed_before)
		    {
			if (!PackageSystem::CheckAndInstallPackagesInteractive ([required_package]))
			{
			    Report::Error (sformat (
				// popup error message, %1 is the package name
				_("Cannot search for SLP repositories
without having %1 package installed"),
				required_package
			    ));
			    y2warning ("Not searching for SLP repositories");
			}
			else
			{
			    SCR::RegisterAgent(.slp, `ag_slp(`SlpAgent()));
			}
		    }
		    string service = (string) WFM::call("select_slp_source");
		    if (service != nil)
			url = service;
		}
		else
		{
		    if (SourceDialogs::EditDialog () == `next)
			url = SourceDialogs::GetURL ();
		}
	    }
	    Wizard::CloseDialog ();
	    if (url != "")
	    {
		if (haskey (repositories, url))
		    continue;

		map parsed = URL::Parse(url);
		if (parsed["scheme"]:"" == "dir")
		{
		    url	= parsed["path"]:url;
		    y2milestone ("un-escaping local directory path: %1", url);
		}
		boolean plaindir = SourceDialogs::IsPlainDir();

		repositories[url]	= $[
		    "url"		: url,
		    "plaindir"		: plaindir,
		    "name"		: SourceDialogs::GetRepoName ()
		];
		update_repo_table ();
	    }
	}
	else if (ret == `edit || ret == `repositories)
	{
	    string url		= (string)
		UI::QueryWidget (`id (`repositories), `CurrentItem);
	    string selected_url	= url;
	    boolean plaindir    = repositories[url,"plaindir"]:false;
	    // change schema if the source type is plaindir
	    // to show the right popup dialog
	    if (plaindir)
	    {
		map parsed = URL::Parse(url);
		url = URL::Build (parsed);
		url	= SourceDialogs::EditPopupType (url, true);
	    }
	    else
		url	= SourceDialogs::EditPopup (url);
	    if (url == "" || url == nil || url == selected_url)
		continue;
	    // remove current url + add new one
	    repositories	= remove (repositories, selected_url);
	    map parsed	= URL::Parse(url);
	    plaindir	= SourceDialogs::IsPlainDir();
	    repositories[url]	= $[
		"url"		: url,
		"plaindir"	: plaindir,
		"name"		: SourceDialogs::GetRepoName ()
	    ];
	    update_repo_table ();
	}
	else if (ret == `delete)
	{
	    string selected	= (string)
		UI::QueryWidget (`id (`repositories), `CurrentItem);
	    if (selected == nil)
		continue;
	    repositories	= remove (repositories, selected);
	    update_repo_table ();
	    if (size (repositories) > 0)
		UI::SetFocus (`id (`repositories));
	}
	else if (ret == `browse)
	{
	    string dir	= UI::AskForExistingDirectory ("",
		// popup for file selection dialog
		_("Path to the Output Directory"));
	    if (dir!= nil)
	    {
		UI::ChangeWidget (`id (`out_dir), `Value, dir);
	    }
	}
	else if (ret == `next)
	{
	    y2internal ("package lock check returned %1", PackageLock::Check ());

	    name	= (string) UI::QueryWidget (`id (`config), `Value);
	    if (name == "")
	    {
		// error popup
		Report::Error(_("Enter the name of the configuration."));
		UI::SetFocus (`id (`config));
		continue;
	    }
	    if (new_configuration &&
		FileUtils::Exists (Kiwi::images_dir + "/" + name))
	    {
		// error popup
		Popup::Error (sformat (_("Configuration with name \"%1\" already exists.
Choose a different one."), name));
		UI::SetFocus (`id (`config));
		continue;
	    }
	    out_dir	= (string) UI::QueryWidget (`id (`out_dir), `Value);
	    if (out_dir == "")
	    {
		// error popup
		Popup::Error (_("Enter the path to the output directory."));
		UI::SetFocus (`id (`out_dir));
		continue;
	    }
	    if (repositories == $[])
	    {
		// error popup
		Popup::Error(_("Specify at least one package repository."));
		UI::SetFocus (`id (`repositories));
		continue;
	    }

	    kiwi_task	= (string)  UI::QueryWidget (`id (`type), `Value);

	    list<string> failed_repositories	= [];
	    map<string,map> new_repositories    = $[];

	    ProductCreator::ResetArch();

	    if (Arch::architecture () == "x86_64")
	    {
		Kiwi::image_architecture	= "x86_64";
		if (UI::QueryWidget (`id (`i386), `Value) == true)
		{
		    Kiwi::image_architecture	= "i386";
		    // closing sources, so they are created again with correct arch (bnc#510971)
		    Pkg::SourceFinishAll ();
		    Pkg::SourceStartManager(false);
		    ProductCreator::SetPackageArch ("i686");
		}
	    }

	    Kiwi::target_i586   = Kiwi::image_architecture == "i386" && (boolean) UI::QueryWidget (`id (`i586), `Value);

	    if (size (repositories) > 0)
	    {
		map<string,integer> current_sources	= $[];
		// delete current repos, that won't be used in config
		foreach (map source, Pkg::SourceEditGet (), {
		    integer srcid       = source["SrcId"]:-1;
		    map data = Pkg::SourceGeneralData (srcid);
		    string url	= data["url"]:"";
		    // there can be more sources with same url, leave there only one
		    if (current_sources[url]:srcid != srcid)
		    {
			y2milestone ("deleting extra source %1 for %2", current_sources[url]:srcid, url);
			Pkg::SourceDelete (current_sources[url]:srcid);
		    }
		    current_sources[url]	= srcid;
		});
		// initialize new repos now
		new_repositories = filter (string url, map repo, repositories, {
		    if (substring (url, 0, 1) == "/")
			url		= "dir://" + url;
		    if (haskey (current_sources, url))
		    {
			current_sources	= remove (current_sources, url);
			return true;
		    }
		    integer source_ret	= -1;
		    string full_url	= url;
		    if (repo["full_url"]:"" != "" && repo["full_url"]:"" != url)
			full_url	= repo["full_url"]:"";

		    map<string,any> repo_map	= $[
                            "name"      : repo["name"]:"" == "" ? full_url : repo["name"]:"",
			    "base_urls"	: [ full_url ],
		    ];

		    if (repo["plaindir"]:false)
		    {
			repo_map["type"]	= "Plaindir";
		    }
		    source_ret = Pkg::RepositoryAdd (repo_map);

		    if (source_ret == -1)
		    {
			failed_repositories = add (failed_repositories, url);
			return false;
		    }
		    return true;
		});
		foreach (string url, integer srcid, current_sources, {
		    Pkg::SourceDelete (srcid);
		});
	    }
	    if (failed_repositories != [])
	    {
		// continue/cancel popup %1 is a \n separated list
		if (!Popup::ContinueCancel (sformat (_("Failed to add these repositories:

%1.

Continue anyway?"), mergestring (failed_repositories, "\n"))))
		{
		    continue;
		}
		else
		{
		    repositories	= new_repositories;
		}
	    }
	    string to_install	= "";
	    if (contains ([ "iso", "xen", "vmx", "usb" ], kiwi_task))
	    {
		string bootdir	= get_bootdir (Config, kiwi_task);
		if (bootdir == "" ||
		    (!FileUtils::Exists ("/usr/share/kiwi/image/" + bootdir) &&
		    !FileUtils::Exists (bootdir))
		)
		{
		    to_install = sformat("kiwi-desc-%1boot", kiwi_task);
		}
		if (to_install != "" && !Package::Install (to_install))
		{
		    Popup::Error (Message::FailedToInstallPackages ());
		    continue;
		}
	    }
	    break;
	}
    }
    string boot	= get_bootdir (Config, kiwi_task);
    if (boot != "" && issubstring (boot, "/"))
    {
	string prefix	= kiwi_task == "pxe" ? "net" : kiwi_task;
	Config[prefix + "boot"] = substring (boot, search (boot, "/") + 1);//FIXME this should not be needed...
    }
    if (ret == `next)
    {
	if (size (repositories) > 0)
	{
	    ProductCreator::enable_sources	= false;
	    Pkg::SourceLoad();
	}
	Config["kiwi_configuration_" + kiwi_task]	= kiwi_configuration;
        Config["_imported"]	= true;
        Config["iso-directory"]	= out_dir +
	    (new_configuration ? "/" + name : "");
	Config	= save_preferences (
	    Config, "defaultdestination", Config["iso-directory"]:"");
	Config["name"]		= name;
	Config["new_configuration"]	= new_configuration;
	Config["sources"]	= maplist (
	    string url, map repo, repositories, ``(url));
	ProductCreator::Config		= Config;
	Kiwi::current_repositories	= repositories;
	Kiwi::kiwi_task	= kiwi_task;
    }
    y2milestone("Returning %1", ret);
    return (symbol) ret;
  }
}
